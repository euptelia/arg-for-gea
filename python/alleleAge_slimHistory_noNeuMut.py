"""
Explore how the performance of GEA is affected by allele ages and how this
effect interact with demographic history,
using tree sequences generated by CONTINUOUS SPACE nonWF models in SLiM
Output:
A table with pos_by_mut, allele age, frequency, mut_effect, delta_LF_mut,
one allele per line
Can be used for timeSeries_multiTimes. Replaced the use of timeSeries_slimHistory.py
Updates compared to alleleAge_slimHistory_crutches.py:
    Neutral mutations are not added
    GEA skipped

tianlin.duan42@gmail.com
2024.03.22
"""
############################# modules #########################################
import msprime
import tskit
# import pyslim # for recapitation
# import matplotlib.pyplot as plt
import scipy.stats as stats
from scipy.spatial import distance_matrix
import numpy as np
# import pandas
import random
import time
# import sys # for sys.exit()
# import allel # for allel.weir_cockerham_fst()
import os # mkdir
# import tracemalloc check memory usage

############################# options #############################
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('-i', '--input',
                    help='Input .trees file with its absolute path',
                    type=str)
args = parser.parse_args()

############################# functions #######################################
def tree_heights(tree_sequences):
    kb = [0]
    mrca_t = []
    for tree in tree_sequences.trees():
        kb.append(tree.interval.right / 1000)
        if tree.has_multiple_roots:
            # Use the maximum time when not coalesced
            mrca_t.append(tree_sequences.metadata["SLiM"]["tick"])
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            mrca_t.append(tree.time(real_root))
    return mrca_t, kb

def tree_height(tree, maximum_tick):
    if tree.has_multiple_roots:
        # Use the maximum time when not coalesced
        tmrca = maximum_tick
    else:
        children = tree.children(tree.root)
        real_root = tree.root if len(children) > 1 else children[0]
        tmrca = (tree.time(real_root))
    return tmrca

# def lf_fitness_loop(ind_x, ind_y, phenotype, optima, dist_mate, sigma_w):
#     """Takes x and y coordinates (array-like), phenotypes (array-like),
#         optima of the localtion of each individual(array-like),
#         a maximum distance for mating (single value),
#         and a standard deviation of fitness function (single value).
#     Return an array of the difference of average fitness of local and foreign individuals.
#     v1: memory efficient but not time efficient
#     """
#     w_foreign = []
#     w_local = []
#     for i in range(len(ind_x)):
#         dist = np.sqrt((ind_x - ind_x[i]) ** 2 + (ind_y - ind_y[i]) ** 2)
#         w_all = 1.0 + stats.norm.pdf(phenotype, optima[i], sigma_w)
#         w_relative = np.array(w_all / np.mean(w_all))
#         w_foreign.append(np.mean(w_relative[dist > dist_mate]))
#         w_local.append(np.mean(w_relative[dist <= dist_mate]))
#     return np.array(w_local), np.array(w_foreign)

def lf_fitness(ind_x, ind_y, phenotype,
               optima, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        environmental optima (array-like), a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return two arrays of the average fitness of local and foreign individuals, respectively.
    v2: time efficient but not memory efficient.
    Try the other version when the number of individuals is large.
    """
    optima=np.array(optima)
    coord = list(zip(ind_x, ind_y))
    dist_matrix = distance_matrix(coord, coord)
    isLocal_matrix = dist_matrix <= dist_mate
    # Calculate fitness matrix (w_matrix[i][j]: individual j at location i) with broadcast
    w_matrix = 1.0 + stats.norm.pdf(np.array(phenotype),
                                    np.array(optima)[:, np.newaxis],
                                    sigma_w)
    # relative fitness
    w_matrix = w_matrix / np.mean(w_matrix, 1)[:, np.newaxis]
    #Average relative fitness of local and foreign individuals
    w_local = np.mean(np.ma.masked_array(w_matrix, np.invert(isLocal_matrix)), 1)
    w_foreign = np.mean(np.ma.masked_array(w_matrix, isLocal_matrix), 1)
    return w_local, w_foreign

############################# program #########################################
# Values
sigma_w = 0.4
dist_mate = 0.12
history = 100000 # number of generations before the focal model

#User input arguments:
path_file_name = args.input
# path_file_name = "/home/tianlin/Documents/github/data/slim_data/glacial_history/historical_optimum0_timeSeries_gradualChange/M2b_smallLowVm_highMig_clineMap/Continuous_nonWF_M2b_glacialHistoryOptimum0_clineMap_mu1.0e-08_sigmaM0.01_sigmaW0.4_sigmaD0.06_mateD0.15_K17000_r1.0e-07_seed142788750963570601_tick100400.trees"

# Remove paths
file_name = path_file_name.split("/")[-1]
model_name = file_name[0:-6]  # Assuming the file name extension is .trees
# Delete seed and tick information for making a directory
short_model_name = "_".join(file_name.split("_")[0:-2])

# figPath = "/home/anadem/github/data/tskit_data/figure/20241201/"
# #Figure path for the current run
# figPath = figPath + model_name + "/"
# if not os.path.exists(figPath):
#     os.mkdir(figPath)

# outBasePath = "/home/tianlin/ubc/data/tskit_data/output/table/realistic_fpr_comparisons/"
outBasePath = "/home/anadem/github/data/tskit_data/output/table/realistic_fpr_comparisons/"
outPath = outBasePath+short_model_name+"/timeSeries/"
if not os.path.exists(outPath):
    os.makedirs(outPath)

# Tree-sequence file from SLiM
ts = tskit.load(path_file_name)
current_tick = ts.metadata['SLiM']['tick']
ind_x, ind_y, ind_z = zip(*ts.individuals_location)
# Genomic position of sites
pos = ts.sites_position
# Genomic position of mutations
pos_by_mut = ts.sites_position[ts.mutations_site]
# Maximum tick
max_tick = ts.metadata["SLiM"]["tick"]
# Number of diploid individuals
N = ts.num_individuals
# Environmental optima
optima = np.array(ts.metadata['SLiM']['user_metadata']['indsOptimum'])
mapValues = np.array(ts.metadata['SLiM']['user_metadata']['mapValues'])

# Recapitation: skipped as no functional mutation was added during this stage
# ts_recap = pyslim.recapitate(ts, ancestral_Ne=5e3,
#                              recombination_rate=1e-7,
#                              random_seed=1)
#
# (tmrca_recap, kb_recap) = tree_heights(ts_recap)
# ts_recap = ts

# Add neutral mutations
mutation_seed = random.randint(1, 2**31)
mut_model1 = msprime.SLiMMutationModel(type=1)
mts = msprime.sim_mutations(ts,
                            rate=5e-8,
                            random_seed=mutation_seed,
                            model=mut_model1,
                            keep=True) #keep the existing mutations
del ts

# Phenotypic effect of each mutation
# 1-dimensional
mut_effect = []
for mut in mts.mutations():
    mut_effect.append(mut.metadata['mutation_list'][0]['selection_coeff'])
mut_effect = np.array(mut_effect)

# 2-dimensional: list of lists, corresponding to phenotypic effect of allele 0/1/2... at each site
mut_effect_lists = []
for site in mts.sites():
    effect_site = [0]
    for mut in site.mutations:
        effect_site.append(mut.metadata['mutation_list'][0]['selection_coeff'])
    mut_effect_lists.append(effect_site)

# Observed extent of local adaptation (local-foreign contrast (LF))
(w_local, w_foreign) = lf_fitness(ind_x, ind_y, ind_z,
                                  optima, dist_mate, sigma_w)
LF_cline = w_local - w_foreign
mean_LF = np.mean(LF_cline)
# Overall extent of local adaptation
#print(mean_LF)


# Contribution of each mutation to LF
# Version 2: randomizing the distribution of the mutation
# Skip calculation for neutral mutations
print("LF_mut calculation")
print(time.ctime())
shuffle_replicates = 1
LF_shuffle = []
t1 = time.time()
index_site = 0
# traverse sites with mutations
for v in mts.variants():
    # Skip calculation and directly append mean_LF as LF_shuffle
    # By definition neutral mutations should not affect phenotypes at all
    if sum(mut_effect_lists[index_site]) == 0:
        index_gt = 1
        while index_gt < len(mut_effect_lists[index_site]):
            LF_shuffle.append(mean_LF)
            index_gt += 1
    else:
        # Calculate the effect of each mutation at the focal site
        index_gt = 1
        # traverse all derived alleles at the site
        while index_gt < len(mut_effect_lists[index_site]):
            # for multiallelic sites, hide all other alleles at the site,
            # but only evaluate one allele at each time
            focal_gt = np.array(v.genotypes)
            focal_gt[focal_gt != index_gt] = 0
            # effect of the focal mutation in each individual
            effect_mut_genomes = np.array(mut_effect_lists[index_site])[focal_gt]
            # Add up the two genomes of each individual
            effect_mut_ind = (effect_mut_genomes[range(0, 2 * N - 1, 2)] +
                              effect_mut_genomes[range(1, 2 * N, 2)])
            phenotype_without_mut = ind_z - effect_mut_ind
            # Shuffle the distribution of the individuals
            # (without changing the observed heterozygosity)
            r = 0
            LF_shuffle_mut = np.zeros(shuffle_replicates)
            while r < shuffle_replicates:
                effect_mut_ind_shuffle = list(effect_mut_ind)  # shallow copy
                np.random.shuffle(effect_mut_ind_shuffle)
                # Phenotype with shuffled mut =
                # phenotypes of each ind - effect of the focal mutation in each ind
                # + effect of the focal mutation in each ind after shuffling
                phenotype_shuffle = phenotype_without_mut + effect_mut_ind_shuffle
                (w_local, w_foreign) = lf_fitness(ind_x, ind_y, phenotype_shuffle,
                                                  optima, dist_mate, sigma_w)
                LF_shuffle_mut[r] = np.mean(w_local - w_foreign)
                r += 1
            LF_shuffle.append(np.mean(LF_shuffle_mut))
            index_gt += 1
    index_site += 1
    if index_site % 10000 == 0:
        print(f"{index_site} sites processed")
delta_LF_mut = mean_LF-LF_shuffle
# Elapsed Time
timer = time.time() - t1
print(str(round((timer/60),2) )+ " minutes used for LF_mut calculation.")
print(time.ctime())

# Age of each mutation
age = mts.mutations_time
pos_by_mut = mts.sites_position[mts.mutations_site]

# Mutation effects by mutation coordinates
effect_by_mut = []
for site in mts.sites():
    for mut in site.mutations:
        effect_by_mut.append(mut.metadata['mutation_list'][0]['selection_coeff'])
effect_by_mut = np.array(effect_by_mut)

# Frequency of each mutation
freq = []
num_samples = mts.num_samples
for v in mts.variants():
    for allele in np.arange(1, v.num_alleles):
        focal_freq = np.count_nonzero(v.genotypes == allele)/num_samples
        freq.append(focal_freq)

# # TMRCA of all samples at the position of each mutation
# tmrca_mut = []
# for p in pos_by_mut:
#     tmrca_mut.append(tree_height(mts.at(p), max_tick))
#
# tmrca_mut = np.full(shape=mts.num_mutations,
#                     fill_value=np.nan)
# i = 0
# for p in pos_by_mut:
#     tmrca_mut[i] = tree_height(mts.at(p), max_tick)
#     i += 1

# Remove negative LF values and 0 allele age for some plots
age_positveLFandAge = age[np.logical_and(delta_LF_mut > 0, age > 0)]
delta_LF_mut_positveLFandAge = delta_LF_mut[np.logical_and(delta_LF_mut > 0,
                                                           age > 0)]
age_positveLFandAge_log = np.log(age_positveLFandAge)
delta_LF_mut_positveLFandAge_log = np.log(delta_LF_mut_positveLFandAge)

# #### Save the data table:
# # Method 1, np table
# # mutation ID, allele age, allele frequency, mutation effect, LF_mut,
# # GEA Kendall's tau and corresponding p-value
# myTable = np.array([np.arange(mts.num_mutations),
#                     age,
#                     freq,
#                     mut_effect,
#                     delta_LF_mut])
# np.savetxt(outPath + model_name + "_fst" + str(round(fst,4)) +
#            "_withNeutralMut_mutSeed" +
#            str(mutation_seed) + "_table.txt",
#            myTable,
#            header="ID, allele_age, allele_freq, effect_size, lf_mut")

# Method 2, loops
# mutation ID, allele age, allele frequency, mutation effect, LF_mut,
# GEA Kendall's tau and corresponding p-value
print("Saving the table...")
print(time.ctime())
out_path_file = (outPath + model_name +
                 "_functionalMut_table.txt")
header = "\t".join(["pos", "age", "freq",
                    "mut_effect","lf_mut"]) + "\n"
with open(out_path_file, "w") as fout:
    fout.write(header)
    for i in range(len(age)):
        words = [pos_by_mut[i],
                        age[i],
                        freq[i],
                        mut_effect[i],
                        delta_LF_mut[i]]
        words = [str(i) for i in words]
        outLine = "\t".join(words) + "\n"
        fout.write(outLine)
print("The table has been saved.")
print(time.ctime())
