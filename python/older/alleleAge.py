"""Explore how the performance of GEA is affected by allele ages and how this effect interact with demographic history,
using tree sequences generated by CONTINUOUS SPACE nonWF models in SLiM
tianlin.duan42@gmail.com
2024.02.26
"""
############################# modules #########################################
import msprime
import tskit
import pyslim
import matplotlib.pyplot as plt
import scipy.stats as stats
from scipy.spatial import distance_matrix
import numpy as np
from time import time

############################# functions #######################################
def tree_heights(ts):
    kb = [0]
    mrca_t = []
    for tree in ts.trees():
        kb.append(tree.interval.right / 1000)
        if tree.has_multiple_roots:
            # Use the maximum time when not coalesced
            mrca_t.append(ts.metadata["SLiM"]["tick"])
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            mrca_t.append(tree.time(real_root))
    return mrca_t, kb

def tree_height(tree, max_tick):
    if tree.has_multiple_roots:
        # Use the maximum time when not coalesced
        tmrca = (max_tick)
    else:
        children = tree.children(tree.root)
        real_root = tree.root if len(children) > 1 else children[0]
        tmrca = (tree.time(real_root))
    return tmrca

def LF_fitness_loop(ind_x, ind_y, phenotype, optimal, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        optimal of the localtion of each individual(array-like),
        a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return an array of the difference of average fitness of local and foreign individuals.
    v1: memory efficient but not time efficient
    """
    w_foreign = []
    w_local = []
    for i in range(len(ind_x)):
        dist = np.sqrt((ind_x - ind_x[i]) ** 2 + (ind_y - ind_y[i]) ** 2)
        w_all = 1.0 + stats.norm.pdf(phenotype, optimal[i], sigma_w)
        w_relative = np.array(w_all / np.mean(w_all))
        w_foreign.append(np.mean(w_relative[dist > dist_mate]))
        w_local.append(np.mean(w_relative[dist <= dist_mate]))
    return np.array(w_local), np.array(w_foreign)

def LF_fitness(ind_x, ind_y, phenotype,
               optimal, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        environmental optimals (array-like), a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return two arrays of the average fitness of local and foreign individuals, respectively.
    v2: time efficient but not memory efficient.
    Try the other version when the number of individuals is large.
    """
    optimal=np.array(optimal)
    coord = list(zip(ind_x, ind_y))
    dist_matrix = distance_matrix(coord, coord)
    isLocal_matrix = dist_matrix <= dist_mate
    # Calculate fitness matrix (w_matrix[i][j]: individual j at location i) with broadcast
    w_matrix = 1.0 + stats.norm.pdf(np.array(phenotype),
                                    np.array(optimal)[:, np.newaxis],
                                    sigma_w)
    # relative fitness
    w_matrix = w_matrix / np.mean(w_matrix, 1)[:, np.newaxis]
    #Average relative fitness of local and foreign individuals
    w_local = np.mean(np.ma.masked_array(w_matrix, np.invert(isLocal_matrix)), 1)
    w_foreign = np.mean(np.ma.masked_array(w_matrix, isLocal_matrix), 1)
    return w_local, w_foreign

############################# program #########################################
#Values
sigma_w = 0.4
dist_mate = 0.1

#M2b
model_name = "Continuous_nonWF_M2b_mu1.0e-09_sigmaM0.4_sigmaW0.4_seed4211585214153878784_tick20000"
# model_name = "Continuous_nonWF_M2b_mu1.0e-09_sigmaM0.4_sigmaW0.4_seed4211585214153878784_tick10400"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed2186716867923388027_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.1_seed2805110583194452015_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.4_seed1207239118116064755_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.01_sigmaW2.0_seed674562876216857337_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.4_seed420342970716621951_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.4_seed4094191535017385840_tick20000"

#Set 1: sigmaM0.1, sigmaW2.0
#M0a
# model_name = "Continuous_nonWF_M0a_mu1.0e-09_sigmaM0.1_seed159493640993233401_tick20000"
#M0b
# model_name = "Continuous_nonWF_M0b_neutralHistory_mu1.0e-09_sigmaM0.1_seed4262922979799227249_tick20000"
#M1a
# model_name = "Continuous_nonWF_M1a_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed2043775523926582509_tick20000"
#M1b
# model_name = "Continuous_nonWF_M1b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed1704698170862545749_tick20000"
#M2a
# model_name = "Continuous_nonWF_M2a_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed432632840517966805_tick20000"
#M2b
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed443882937971756522_tick20000"


inPath = "/home/tianlin/Documents/github/data/slim_data/"
figPath = "/home/tianlin/Documents/github/data/tskit_data/figure/"
outPath = "/home/tianlin/Documents/github/data/tskit_data/output/"

# Tree-sequence file from SLiM
ts = tskit.load(inPath + model_name + ".trees")
ind_x, ind_y, ind_z = zip(*ts.individuals_location)
# Genomic position of sites
pos = ts.sites_position
# Genomic position of mutations
pos_by_mut = ts.sites_position[ts.mutations_site]
# Maximum tick
max_tick = ts.metadata["SLiM"]["tick"]
# Number of diploid individuals
N = ts.num_individuals
# Environmental optimal
optimal = np.array(ind_x)

# Recapitation
ts_recap = pyslim.recapitate(ts, ancestral_Ne=5e3,
                             recombination_rate=1e-7,
                             random_seed=1)

(tmrca_recap, kb_recap) = tree_heights(ts_recap)

# Phenotypic effect of each mutation
# 1-dimensional
mut_effect = []
for mut in ts.mutations():
    mut_effect.append(mut.metadata['mutation_list'][0]['selection_coeff'])
mut_effect = np.array(mut_effect)

# 2-dimensional: list of lists, corresponding to phenotypic effect of allele 0/1/2... at each site
mut_effect_lists = []
for site in ts.sites():
    effect_site = [0]
    for mut in site.mutations:
        effect_site.append(mut.metadata['mutation_list'][0]['selection_coeff'])
    mut_effect_lists.append(effect_site)

# Observed extent of local adaptation (local-foreign contrast (LF))
# (w_local, w_foreign) = LF_fitness_loop(ind_x, ind_y, ind_z,
#                                   ind_x, dist_mate, sigma_w)
# print(timer1) # 3.608828544616699

(w_local, w_foreign) = LF_fitness(ind_x, ind_y, ind_z,
                                  optimal, dist_mate, sigma_w)
#print(timer2) # 1.456526279449463

LF_cline = w_local - w_foreign
mean_LF = np.mean(LF_cline)

# Overall extent of local adaptation
print(mean_LF)

# Display the average fitness of local and foreign populations
plt.figure(1)
plt.boxplot([w_local, w_foreign],
            labels=["Local", "Foreign"])
plt.xlabel("Groups")
plt.ylabel("Average relative fitness")
# plt.show()
plt.savefig(figPath + str(model_name) + "_test_localAdapt.png")
plt.close()

# # Contribution of each mutation to LF
# # Version 1: drop off (discarded)
# index_site = 0
# LF_without_mut = []
# t = time()
# for v in ts.variants():
#     # Calculate the effect of each mutation at the focal site
#     index_gt = 1
#     while index_gt < len(mut_effect_lists[index_site]):
#         #hide other mutations except the focal mutation
#         focal_gt = np.array(v.genotypes)
#         focal_gt[focal_gt != index_gt] = 0
#         # effect of the focal mutation in each individual
#         effect_mut_genomes = np.array(mut_effect_lists[index_site])[focal_gt]
#         # Add up two genomes of each individual
#         effect_mut_ind = (effect_mut_genomes[range(0, 2*N-1, 2)]
#                         + effect_mut_genomes[range(1, 2*N, 2)])
#         # Phenotype without the mut = phenotypes of each ind - effect of the focal mutation in each ind
#         phenotype_without_mut = ind_z - effect_mut_ind
#         (w_local, w_foreign) = LF_fitness(ind_x, ind_y, phenotype_without_mut,
#                                           ind_x, dist_mate, sigma_w)
#         LF_without_mut.append(np.mean(w_local-w_foreign))
#         index_gt += 1
#     index_site += 1
#     if index_site % 100 == 0:
#         print(f"{index_site} sites processed")
# delta_LF_mut = mean_LF-LF_without_mut
# # Elapsed Time
# timer = time() - t
# print(timer/60)

# Contribution of each mutation to LF
#Version 2: randomizing the distribution of the mutation
shuffle_replicates = 1
LF_shuffle = []
t = time()
index_site = 0
# traverse sites with mutations
for v in ts.variants():
    # Calculate the effect of each mutation at the focal site
    index_gt = 1
    # traverse all derived alleles at the site
    while index_gt < len(mut_effect_lists[index_site]):
        # for multiallelic sites, hide other alleles at the site except the focal allele,
        # leave only one allele at each time
        focal_gt = np.array(v.genotypes)
        focal_gt[focal_gt != index_gt] = 0
        # effect of the focal mutation in each individual
        effect_mut_genomes = np.array(mut_effect_lists[index_site])[focal_gt]
        # Add up the two genomes of each individual
        effect_mut_ind = (effect_mut_genomes[range(0, 2*N-1, 2)] +
                          effect_mut_genomes[range(1, 2*N, 2)])
        phenotype_without_mut = ind_z - effect_mut_ind
        # Shuffle the distribution of the individuals
        # (without changing the observed heterozygosity)
        r = 0
        LF_shuffle_mut = np.zeros(shuffle_replicates)
        while r < shuffle_replicates:
            effect_mut_ind_shuffle = list(effect_mut_ind) # shallow copy
            np.random.shuffle(effect_mut_ind_shuffle)
            #print(list(effect_mut_ind))
            #print(effect_mut_ind_shuffle)
            # Phenotype with shuffled mut =
            # phenotypes of each ind - effect of the focal mutation in each ind
            # + effect of the focal mutation in each ind after shuffling
            phenotype_shuffle = phenotype_without_mut + effect_mut_ind_shuffle
            (w_local, w_foreign) = LF_fitness(ind_x, ind_y, phenotype_shuffle,
                                              ind_x, dist_mate, sigma_w)
            LF_shuffle_mut[r] = np.mean(w_local - w_foreign)
            r += 1
        LF_shuffle.append(np.mean(LF_shuffle_mut))
        index_gt += 1
    index_site += 1
    if index_site % 100 == 0:
        print(f"{index_site} sites processed")
delta_LF_mut = mean_LF-LF_shuffle
# Elapsed Time
timer = time() - t
print(timer/60)
# for 10 replicates, 180 sites take 30 minutes

# Save the contribution of each mutation to LF
with open(outPath+model_name + "delta_LF_shuffle" +
          str(shuffle_replicates) + "_mut.txt", "w") as fout:
    for item in delta_LF_mut:
        fout.write(str(item) + "\n")
fout.close()

# Load LF from file
delta_LF_mut = np.loadtxt(outPath+model_name + "delta_LF_shuffle" +
          str(shuffle_replicates) + "_mut.txt")

# Age of each mutation
age = ts.mutations_time
pos_by_mut = ts.sites_position[ts.mutations_site]
effect_by_mut = []
for site in ts.sites():
    for mut in site.mutations:
        effect_by_mut.append(mut.metadata['mutation_list'][0]['selection_coeff'])
effect_by_mut = np.array(effect_by_mut)

# Frequency of each mutation
freq = []
num_samples = ts.num_samples
for v in ts.variants():
    for allele in np.arange(1, v.num_alleles):
        focal_freq = np.count_nonzero(v.genotypes == allele)/num_samples
        freq.append(focal_freq)




# TMRCA of all samples at the position of each mutation
tmrca_mut = []
for p in pos_by_mut:
    tmrca_mut.append(tree_height(ts_recap.at(p), max_tick))

# Remove negative LF values and 0 allele age for some plots
tempx = age[np.logical_and(delta_LF_mut > 0, age > 0)]
tempy = delta_LF_mut[np.logical_and(delta_LF_mut > 0, age > 0)]
tempx_log = np.log(tempx)
tempy_log = np.log(tempy)




#### Basic plots
# Hist LF
plt.hist(delta_LF_mut, bins=100,
         color="grey")
plt.xlabel("$LF_{mut}$")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_LFhist.png",
            dpi=300)
plt.close()

# Histogram of positive LF
plt.hist(tempy, bins=100,
         color="grey")
# plt.title("With local adapation")
plt.xlabel("$LF_{mut}$")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_LFhist_positive.png",
            dpi=300)
plt.close()

# Cumulative plot of LF_mut
expected_explained_proportion = 0.8
sorted_lfmut = np.array(list(reversed(sorted(tempy))))
positiveTotal = sum(sorted_lfmut)
cumulative_lf = [0] + [sum(sorted_lfmut[0:k+1])/positiveTotal
                       for k in range(len(sorted_lfmut))]
# How many alleles do we need to account for 80% of current local adaptation?
gea_goal = sum(np.array(cumulative_lf) < expected_explained_proportion)
explained = cumulative_lf[gea_goal]
plt.plot(range(len(sorted_lfmut)+1), cumulative_lf,
         color="lightseagreen")
plt.xlabel("Mutations sorted in descending order of $LF_{mut}$")
plt.ylabel("Cumulative proportion of positive LF")
# plt.axvline(x=gea_goal, color="firebrick", linestyle="dotted")
# plt.axhline(y=explained, color="firebrick", linestyle="dotted")
plt.plot([gea_goal+1, gea_goal+1], [0, explained],
         color="firebrick", linestyle="dotted")
plt.plot([0, gea_goal+1], [explained, explained],
         color="firebrick", linestyle="dotted")
plt.annotate(str(gea_goal), xy=(gea_goal+1, explained),
             xytext=(gea_goal + 1 + len(cumulative_lf)/40, 0),
             color="firebrick")
plt.savefig(figPath + model_name + "_LFcumulative_positive.png",
            dpi=300)
plt.close()

# # LF ~ phenotypic effect size
# plt.plot(abs(mut_effect), delta_LF_mut,
#          marker="o", linestyle="",
#          color="saddlebrown", alpha=0.1)
# plt.xlabel("|Phenptypic effect size|")
# # plt.ylabel("$LF_{mutation}$ (ln)")
# plt.ylabel("$LF_{mutation}$")
# # plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
# #             dpi=100)
# plt.savefig(figPath+model_name+"continuousWF_phenoEffectAndLF.png",
#             dpi=300)
# plt.close()

# LF ~ |phenotypic effect size|
plt.scatter(abs(mut_effect), delta_LF_mut,
            marker="o",
            c=age, alpha=0.2)
plt.xlabel("|Phenotypic effect size|")
plt.ylabel("$LF_{mut}$")
plt.colorbar()
plt.tight_layout()
plt.savefig(figPath+model_name+"_phenoEffectAndLF_ageColor.png",
            dpi=300)
plt.close()

# LF ~ allele age
res = stats.linregress(tempx_log, tempy_log)
rsquared = round(res.rvalue ** 2, 3)
linearp = '{:0.2e}'.format(res.pvalue)
spr = stats.spearmanr(age, delta_LF_mut)
spr_positive = stats.spearmanr(tempx, tempy)

plt.figure(1)
plt.plot(tempx_log, tempy_log,
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.1)
plt.plot(sorted(tempx_log),
         res.intercept + np.array(sorted(tempx_log))*res.slope,
         color = "cornflowerblue")
plt.text(0, min(tempy_log)+(max(tempy_log)-min(tempy_log))*0.9,
         "$r^{2}$="+str(rsquared)+"\n" + "p-value=" + str(linearp),
         color = "cornflowerblue")
# plt.axline((0,res.intercept),
#            slope=res.slope, color="cornflowerblue",
#            label = "")
# plt.title("With local adapation")
plt.xlabel("ln(Mutation age)")
plt.ylabel("ln(Positive $LF_{mut})$")
#plt.xscale("linear")
#plt.yscale("linear")
plt.savefig(figPath+model_name+"_ageAndLF_ln.png",
            dpi=300)
plt.close()



#### cor Freq-Env as a proximation of GEA
# Divide the population into 10x10 sample-populations, for each sample population,
# calculate the correlation between allele frequency of each mutation and average local environmental variable(optimal)
# Assign a two-digit sample-pop id for each individual
# |90|91|92|93|94|95|96|97|98|99|
# ...
# |20|21|22|23|24|25|26|27|28|29|
# |10|11|12|03|14|15|16|17|18|19|
# |00|01|02|03|04|05|06|07|08|09|
map_width = 1.0
map_height = 1.0
# Only works when both num_row and num_col <= 10
num_row = 10
num_col = 10
num_sample_pop = num_row * num_col
sample_pop_ids = np.zeros(ts.num_individuals)
sample_pop_ids[:] = np.nan
i = 0
for ind in ts.individuals():
    x = int(ind.location[0]/(map_width/num_row))
    y = int(ind.location[1]/(map_width/num_col))
    # Push the ones on the upper boundaries back
    x = x if x < num_row else (num_row-1)
    y = y if y < num_col else (num_col-1)
    sample_pop_ids[i] = (x+y*10)
    i += 1
# # Check the sample size of the grids
# plt.hist(sample_pop_ids, bins=100,
#          color="grey")
# plt.savefig(figPath+model_name+"_subsample_size.png",
#             dpi=300)
# plt.close()

# A collection of individual IDs for each sample population
inds_sample_pop = {}
# Average environmental optimal of each sample population,
# calculated by the position of all local individuals
env_sample_pop = np.zeros(num_sample_pop)
env_sample_pop[:] = np.nan
# A vector of allele frequencies of all mutations for each sample population
freq_sample_pop = np.zeros(shape=(ts.num_sites, num_sample_pop))
freq_sample_pop[:] = np.nan
for focal_pop_id in np.arange(num_sample_pop):
    focal_ind_list = np.array(np.where(sample_pop_ids == focal_pop_id)[0])
    focal_genome_list = np.stack((focal_ind_list*2,focal_ind_list*2+1)).ravel('F')
    inds_sample_pop[focal_pop_id] = focal_ind_list
    # Current map: local env optimals = x coordinates of local samples
    env_sample_pop[focal_pop_id] = np.mean(ts.individuals_location[focal_ind_list][:, 0])
    # Calculate the derived allele frequency of all functional mutations in focal population
    j = 0
    for v in ts.variants(samples=focal_genome_list):
        # Will cause an ERROR for multi-allelic sites
        derived_freq = sum(v.genotypes)/len(focal_genome_list)
        # print(len(focal_ind_list))
        # print(len(v.genotypes))
        # print(v.frequencies())
        # print(derived_freq)
        freq_sample_pop[j][focal_pop_id] = derived_freq
        j += 1


# Correlation between allele frequency and environmental optima
# correlation coefficient and p-value
cor_GE = np.zeros(shape=(2, ts.num_sites))
cor_GE[:] = np.nan
for i in np.arange(ts.num_sites):
    # fixed/lost mutations would raise a statistic error
    if sum(freq_sample_pop[i]) > 0:
        # position 0: correlation coefficients, position 1: p-values
        # (cor_GE[0][i], cor_GE[1][i]) = stats.spearmanr(freq_sample_pop[i], env_sample_pop)
        (cor_GE[0][i], cor_GE[1][i]) = stats.kendalltau(freq_sample_pop[i], env_sample_pop)

# LF_mut ~ cor_GE p-values, colored by age
plt.scatter(cor_GE[1], delta_LF_mut,
         marker="o",
         c=age, alpha=0.2)
plt.xlabel("GEA p-values")
plt.ylabel("$LF_{mut}$")
plt.colorbar()
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_ageColor.png",
            dpi=300)
plt.close()

# ln(positive LF_mut) ~ ln(cor_GE p-values), colored by age
# Remove negative LF values and 0 allele age for some plots
positive_lfmut_age = age[delta_LF_mut > 0]
positive_lfmut = delta_LF_mut[delta_LF_mut > 0]
positive_lfmut_gea = cor_GE[1][delta_LF_mut > 0]
(tau, p) = stats.kendalltau(positive_lfmut_age, positive_lfmut)

plt.scatter(np.log(positive_lfmut_gea), np.log(positive_lfmut),
         marker="o",
         c=positive_lfmut_age, alpha=0.2)
plt.xlabel("ln(GEA p-values)")
plt.ylabel("ln($LF_{mut}$)")
plt.colorbar()
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_ageColor_positveLn.png",
            dpi=300)
plt.close()

plt.scatter(abs(cor_GE[0]), delta_LF_mut,
         marker="o",
         c=age, alpha=0.2)
plt.xlabel("|GEA Kendall's tau|")
plt.ylabel("$LF_{mut}$")
plt.colorbar()
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEcoef_vs_LF_mut_ageColor.png",
            dpi=300)
plt.close()

# # Check the distribution of mutation with largest LF_mut
# np.nanargmax(delta_LF_mut)
# maxlf_mut = np.reshape(freq_sample_pop[np.nanargmax(delta_LF_mut)],
#                        (10, 10))
# # Plot
# fig, ax = plt.subplots()
# im = ax.imshow(maxlf_mut)
# plt.savefig(figPath+model_name+"_maxLF_distribute.png",
#             dpi=300)
# plt.close()
#
# #Check the distribution of the mutation with most significant cor_GE
# np.nanargmin(cor_GE[1])
# minp_mut = np.reshape(freq_sample_pop[np.nanargmin(cor_GE[1])],
#                       (10, 10))
# #Plot
# fig, ax = plt.subplots()
# im = ax.imshow(minp_mut)
# plt.savefig(figPath+model_name+"_min_p_distribute.png",
#             dpi=300)
# plt.close()

# Allele frequencies
# LF_mut ~ cor_GE p-values, colored by Allele frequencies
plt.scatter(cor_GE[1], delta_LF_mut,
         marker="o",
         c=freq, alpha=0.2)
plt.xlabel("GEA p-values")
plt.ylabel("$LF_{mut}$")
plt.colorbar()
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_freqColor.png",
            dpi=300)
plt.close()

