"""
This is a python module to manipulate tree sequences generated by SLiM and
calculate statistics that are related to local adaptation.
tianlin.duan42@gmail.com
2020.06.05
"""

############################# modules #########################################
import msprime
import tskit
import pyslim
import matplotlib.pyplot as plt
import scipy.stats as stats
from scipy.spatial import distance_matrix
import numpy as np
import random
from time import time
import sys # for sys.exit()
import allel # for allel.weir_cockerham_fst()
import os # mkdir

############################# functions #######################################
def tree_heights(treeSequences):
    kb = [0]
    mrca_t = []
    for tree in treeSequences.trees():
        kb.append(tree.interval.right / 1000)
        if tree.has_multiple_roots:
            # Use the maximum time when not coalesced
            mrca_t.append(treeSequences.metadata["SLiM"]["tick"])
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            mrca_t.append(tree.time(real_root))
    return mrca_t, kb

def tree_height(tree, max_tick):
    if tree.has_multiple_roots:
        # Use the maximum time when not coalesced
        tmrca = (max_tick)
    else:
        children = tree.children(tree.root)
        real_root = tree.root if len(children) > 1 else children[0]
        tmrca = (tree.time(real_root))
    return tmrca

def LF_fitness_loop(ind_x, ind_y, phenotype, optima, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        optima of the localtion of each individual(array-like),
        a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return an array of the difference of average fitness of local and foreign individuals.
    v1: memory efficient but not time efficient
    """
    w_foreign = []
    w_local = []
    for i in range(len(ind_x)):
        dist = np.sqrt((ind_x - ind_x[i]) ** 2 + (ind_y - ind_y[i]) ** 2)
        w_all = 1.0 + stats.norm.pdf(phenotype, optima[i], sigma_w)
        w_relative = np.array(w_all / np.mean(w_all))
        w_foreign.append(np.mean(w_relative[dist > dist_mate]))
        w_local.append(np.mean(w_relative[dist <= dist_mate]))
    return np.array(w_local), np.array(w_foreign)

def LF_fitness(ind_x, ind_y, phenotype,
               optima, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        environmental optima (array-like), a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return two arrays of the average fitness of local and foreign individuals, respectively.
    v2: time efficient but not memory efficient.
    Try the other version when the number of individuals is large.
    """
    optima=np.array(optima)
    coord = list(zip(ind_x, ind_y))
    dist_matrix = distance_matrix(coord, coord)
    isLocal_matrix = dist_matrix <= dist_mate
    # Calculate fitness matrix (w_matrix[i][j]: individual j at location i) with broadcast
    w_matrix = 1.0 + stats.norm.pdf(np.array(phenotype),
                                    np.array(optima)[:, np.newaxis],
                                    sigma_w)
    # relative fitness
    w_matrix = w_matrix / np.mean(w_matrix, 1)[:, np.newaxis]
    #Average relative fitness of local and foreign individuals
    w_local = np.mean(np.ma.masked_array(w_matrix, np.invert(isLocal_matrix)), 1)
    w_foreign = np.mean(np.ma.masked_array(w_matrix, isLocal_matrix), 1)
    return w_local, w_foreign


def calculate_lfmut(ts, dist_mate, sigma_w):
    '''
    Calculate the contribution of each mutation to LF
    input: tree sequences, maximum mating distance and the sd of Gaussian
            stabilizing selection;
    return: mean LF and an array of LF_mut
    Version 2: Randomize the distribution of the mutation and skip calculation
    for neutral mutations
    '''
    # Make a list of lists of mutation effects,
    # corresponding to phenotypic effect of allele 0/1/2... at each site
    ind_x, ind_y, ind_z = zip(*ts.individuals_location)
    N = ts.num_individuals
    optima = np.array(ts.metadata['SLiM']['user_metadata']['indsOptimum'])
    mut_effect_lists = []
    for site in ts.sites():
        effect_site = [0]
        for mut in site.mutations:
            effect_site.append(
                mut.metadata['mutation_list'][0]['selection_coeff'])
        mut_effect_lists.append(effect_site)

    # Observed extent of local adaptation (local-foreign contrast (LF))
    (w_local, w_foreign) = LF_fitness(ind_x, ind_y, ind_z,
                                      optima, dist_mate, sigma_w)
    LF_cline = w_local - w_foreign
    mean_LF = np.mean(LF_cline)

    shuffle_replicates = 1
    LF_shuffle = []
    index_site = 0
    # traverse sites with mutations
    for v in ts.variants():
        # Skip calculation and directly append mean_LF as LF_shuffle
        # By definition neutral mutations should not affect phenotypes at all
        if sum(mut_effect_lists[index_site]) == 0:
            index_gt = 1
            while index_gt < len(mut_effect_lists[index_site]):
                LF_shuffle.append(mean_LF)
                index_gt += 1
        else:
            # Calculate the effect of each mutation at the focal site
            index_gt = 1
            # traverse all derived alleles at the site
            while index_gt < len(mut_effect_lists[index_site]):
                # for multiallelic sites, hide other alleles at the site except the focal allele,
                # leave only one allele at each time
                focal_gt = np.array(v.genotypes)
                focal_gt[focal_gt != index_gt] = 0
                # effect of the focal mutation in each individual
                effect_mut_genomes = np.array(mut_effect_lists[index_site])[
                    focal_gt]
                # Add up the two genomes of each individual
                effect_mut_ind = (effect_mut_genomes[range(0, 2 * N - 1, 2)] +
                                  effect_mut_genomes[range(1, 2 * N, 2)])
                phenotype_without_mut = ind_z - effect_mut_ind
                # Shuffle the distribution of the individuals
                # (without changing the observed heterozygosity)
                r = 0
                LF_shuffle_mut = np.zeros(shuffle_replicates)
                while r < shuffle_replicates:
                    effect_mut_ind_shuffle = list(effect_mut_ind)  # shallow copy
                    np.random.shuffle(effect_mut_ind_shuffle)
                    # Phenotype with shuffled mut =
                    # phenotypes of each ind - effect of the focal mutation in each ind
                    # + effect of the focal mutation in each ind after shuffling
                    phenotype_shuffle = phenotype_without_mut + effect_mut_ind_shuffle
                    (w_local, w_foreign) = LF_fitness(ind_x, ind_y,
                                                      phenotype_shuffle,
                                                      optima, dist_mate,
                                                      sigma_w)
                    LF_shuffle_mut[r] = np.mean(w_local - w_foreign)
                    r += 1
                LF_shuffle.append(np.mean(LF_shuffle_mut))
                index_gt += 1
        index_site += 1
        if index_site % 10000 == 0:
            print(f"{index_site} sites processed")
    delta_LF_mut = mean_LF - LF_shuffle
    return(mean_LF, delta_LF_mut)
