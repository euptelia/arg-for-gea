"""Explore how the performance of GEA is affected by allele ages and how this effect interact with demographic history,
using tree sequences generated by CONTINUOUS SPACE nonWF models in SLiM
tianlin.duan42@gmail.com
2024.02.26
"""
############################# modules #########################################
import msprime
import tskit
import pyslim
import matplotlib.pyplot as plt
import scipy.stats as stats
from scipy.spatial import distance_matrix
import numpy as np
from time import time

############################# functions #######################################
def tree_heights(ts):
    kb = [0]
    mrca_t = []
    for tree in ts.trees():
        kb.append(tree.interval.right / 1000)
        if tree.has_multiple_roots:
            # Use the maximum time when not coalesced
            mrca_t.append(ts.metadata["SLiM"]["tick"])
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            mrca_t.append(tree.time(real_root))
    return mrca_t, kb

def tree_height(tree, max_tick):
    if tree.has_multiple_roots:
        # Use the maximum time when not coalesced
        tmrca = (max_tick)
    else:
        children = tree.children(tree.root)
        real_root = tree.root if len(children) > 1 else children[0]
        tmrca = (tree.time(real_root))
    return tmrca

def LF_fitness_loop(ind_x, ind_y, phenotype, optimal, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        optimal of the localtion of each individual(array-like),
        a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return an array of the difference of average fitness of local and foreign individuals.
    v1: memory efficient but not time efficient
    """
    w_foreign = []
    w_local = []
    for i in range(len(ind_x)):
        dist = np.sqrt((ind_x - ind_x[i]) ** 2 + (ind_y - ind_y[i]) ** 2)
        w_all = 1.0 + stats.norm.pdf(phenotype, optimal[i], sigma_w)
        w_relative = np.array(w_all / np.mean(w_all))
        w_foreign.append(np.mean(w_relative[dist > dist_mate]))
        w_local.append(np.mean(w_relative[dist <= dist_mate]))
    return np.array(w_local), np.array(w_foreign)

def LF_fitness(ind_x, ind_y, phenotype,
               optimal, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        environmental optimals (array-like), a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return two arrays of the average fitness of local and foreign individuals, respectively.
    v2: time efficient but not memory efficient.
    Try the other version when the number of individuals is large.
    """
    optimal=np.array(optimal)
    coord = list(zip(ind_x, ind_y))
    dist_matrix = distance_matrix(coord, coord)
    isLocal_matrix = dist_matrix <= dist_mate
    # Calculate fitness matrix (w_matrix[i][j]: individual j at location i) with broadcast
    w_matrix = 1.0 + stats.norm.pdf(np.array(phenotype),
                                    np.array(optimal)[:, np.newaxis],
                                    sigma_w)
    # relative fitness
    w_matrix = w_matrix / np.mean(w_matrix, 1)[:, np.newaxis]
    #Average relative fitness of local and foreign individuals
    w_local = np.mean(np.ma.masked_array(w_matrix, np.invert(isLocal_matrix)), 1)
    w_foreign = np.mean(np.ma.masked_array(w_matrix, isLocal_matrix), 1)
    return w_local, w_foreign

############################# program #########################################
#Values
sigma_w = 0.4
dist_mate = 0.1
# model_name = "Continuous_nonWF_M2b_mu1.0e-09_sigmaM0.4_sigmaW0.4_seed4211585214153878784_tick20000"
# model_name = "Continuous_nonWF_M2b_mu1.0e-09_sigmaM0.4_sigmaW0.4_seed4211585214153878784_tick10400"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed2186716867923388027_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.1_seed2805110583194452015_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.4_seed1207239118116064755_tick20000"
model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.01_sigmaW2.0_seed674562876216857337_tick20000"

inPath = "/home/tianlin/Documents/github/data/slim_data/"
figPath = "/home/tianlin/Documents/github/data/tskit_data/figure/"
outPath = "/home/tianlin/Documents/github/data/tskit_data/output/"

# Tree-sequence file from SLiM
ts = tskit.load(inPath + model_name + ".trees")
ind_x, ind_y, ind_z = zip(*ts.individuals_location)
# Genomic position of sites
pos = ts.sites_position
# Genomic position of mutations
pos_by_mut = ts.sites_position[ts.mutations_site]
# Maximum tick
max_tick = ts.metadata["SLiM"]["tick"]
# Number of diploid individuals
N = ts.num_individuals
# Environmental optimal
optimal = np.array(ind_x)

# Recapitation
ts_recap = pyslim.recapitate(ts, ancestral_Ne=5e3,
                             recombination_rate=1e-7,
                             random_seed=1)

(tmrca_recap, kb_recap) = tree_heights(ts_recap)

# Phenotypic effect of each mutation
# 1-dimensional
mut_effect = []
for mut in ts.mutations():
    mut_effect.append(mut.metadata['mutation_list'][0]['selection_coeff'])
mut_effect = np.array(mut_effect)

# 2-dimensional: list of lists, corresponding to phenotypic effect of allele 0/1/2... at each site
mut_effect_lists = []
for site in ts.sites():
    effect_site = [0]
    for mut in site.mutations:
        effect_site.append(mut.metadata['mutation_list'][0]['selection_coeff'])
    mut_effect_lists.append(effect_site)

# Observed extent of local adaptation (local-foreign contrast (LF))
# (w_local, w_foreign) = LF_fitness_loop(ind_x, ind_y, ind_z,
#                                   ind_x, dist_mate, sigma_w)
# print(timer1) # 3.608828544616699

(w_local, w_foreign) = LF_fitness(ind_x, ind_y, ind_z,
                                  optimal, dist_mate, sigma_w)
#print(timer2) # 1.456526279449463

LF_cline = w_local - w_foreign
mean_LF = np.mean(LF_cline)

print(mean_LF)
plt.figure(1)
plt.boxplot([w_local, w_foreign],
            labels=["Local", "Foreign"])
plt.xlabel("Groups")
plt.ylabel("Average relative fitness")
# plt.show()
plt.savefig(figPath + str(model_name) + "_test_localAdapt.png")
plt.close()

# # Contribution of each mutation to LF
# # Version 1: drop off (discard)
# index_site = 0
# LF_without_mut = []
# t = time()
# for v in ts.variants():
#     # Calculate the effect of each mutation at the focal site
#     index_gt = 1
#     while index_gt < len(mut_effect_lists[index_site]):
#         #hide other mutations except the focal mutation
#         focal_gt = np.array(v.genotypes)
#         focal_gt[focal_gt != index_gt] = 0
#         # effect of the focal mutation in each individual
#         effect_mut_genomes = np.array(mut_effect_lists[index_site])[focal_gt]
#         # Add up two genomes of each individual
#         effect_mut_ind = (effect_mut_genomes[range(0, 2*N-1, 2)]
#                         + effect_mut_genomes[range(1, 2*N, 2)])
#         # Phenotype without the mut = phenotypes of each ind - effect of the focal mutation in each ind
#         phenotype_without_mut = ind_z - effect_mut_ind
#         (w_local, w_foreign) = LF_fitness(ind_x, ind_y, phenotype_without_mut,
#                                           ind_x, dist_mate, sigma_w)
#         LF_without_mut.append(np.mean(w_local-w_foreign))
#         index_gt += 1
#     index_site += 1
#     if index_site % 100 == 0:
#         print(f"{index_site} sites processed")
# delta_LF_mut = mean_LF-LF_without_mut
# # Elapsed Time
# timer = time() - t
# print(timer/60)

# # Contribution of each mutation to LF
# #Version 2: randomizing the distribution of the mutation
index_site = 0
shuffle_replicates = 1
LF_shuffle = []
t = time()
# traverse sites with mutations
for v in ts.variants():
    # Calculate the effect of each mutation at the focal site
    index_gt = 1
    # traverse derived alleles at the site
    while index_gt < len(mut_effect_lists[index_site]):
        # for multiallelic sites, hide other alleles at the site except the focal allele,
        # leave only one allele at each time
        focal_gt = np.array(v.genotypes)
        focal_gt[focal_gt != index_gt] = 0
        # effect of the focal mutation in each individual
        effect_mut_genomes = np.array(mut_effect_lists[index_site])[focal_gt]
        # Add up the two genomes of each individual
        effect_mut_ind = (effect_mut_genomes[range(0, 2*N-1, 2)]
                        + effect_mut_genomes[range(1, 2*N, 2)])

        phenotype_without_mut = ind_z - effect_mut_ind
        # Shuffle the distribution of the individuals (without changing observed heterozygosity)
        r = 0
        LF_shuffle_mut = np.zeros(shuffle_replicates)
        while r < shuffle_replicates:
            effect_mut_ind_shuffle = list(effect_mut_ind) # shallow copy
            np.random.shuffle(effect_mut_ind_shuffle)
            #print(list(effect_mut_ind))
            #print(effect_mut_ind_shuffle)
            # Phenotype with shuffled mut = phenotypes of each ind - effect of the focal mutation in each ind
            #                               + effect of the focal mutation in each ind after shuffling
            phenotype_shuffle = phenotype_without_mut + effect_mut_ind_shuffle
            (w_local, w_foreign) = LF_fitness(ind_x, ind_y, phenotype_shuffle,
                                              ind_x, dist_mate, sigma_w)
            LF_shuffle_mut[r] = np.mean(w_local - w_foreign)
            r += 1
        LF_shuffle.append(np.mean(LF_shuffle_mut))
        index_gt += 1
    index_site += 1
    if index_site % 100 == 0:
        print(f"{index_site} sites processed")
delta_LF_mut = mean_LF-LF_shuffle
# Elapsed Time
timer = time() - t
print(timer/60)
# for 10 replicates, 180 sites take 30 minutes

# Save the contribution of each mutation to LF
with open(outPath+model_name + "delta_LF_shuffle" +
          str(shuffle_replicates) + "_mut.txt", "w") as fout:
    for item in delta_LF_mut:
        fout.write(str(item) + "\n")
fout.close()

# Load LF from file
delta_LF_mut = np.loadtxt(outPath+model_name + "delta_LF_shuffle" +
          str(shuffle_replicates) + "_mut.txt")

# Age of each mutation
age = ts.mutations_time
pos_by_mut = ts.sites_position[ts.mutations_site]
effect_by_mut = []
for site in ts.sites():
    for mut in site.mutations:
        effect_by_mut.append(mut.metadata['mutation_list'][0]['selection_coeff'])
effect_by_mut = np.array(effect_by_mut)



# TMRCA of all samples at the position of each mutation
tmrca_mut = []
for p in pos_by_mut:
    tmrca_mut.append(tree_height(ts_recap.at(p), max_tick))

# Remove negative LF values and 0 allele age for some plots
tempx = age[np.logical_and(delta_LF_mut > 0, age > 0)]
tempy = delta_LF_mut[np.logical_and(delta_LF_mut > 0, age > 0)]
tempx_log = np.log(tempx)
tempy_log = np.log(tempy)
res = stats.linregress(tempx_log, tempy_log)
spr = stats.spearmanr(age, delta_LF_mut)
spr_positive = stats.spearmanr(tempx, tempy)



#### Basic plots
# Hist LF
plt.hist(delta_LF_mut, bins=100,
         color="grey")
plt.xlabel("$LF_{mutation}$")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_localAdapt_ageAndLF_LFhist.png",
            dpi=300)
plt.close()

# Histogram of positive LF
plt.hist(tempy, bins=100,
         color="grey")
# plt.title("With local adapation")
plt.xlabel("$LF_{mutation}$")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_localAdapt_LFhist_positive.png",
            dpi=300)
plt.close()

# Cumulative plot
sorted_lfmut = np.array(list(reversed(sorted(tempy))))
positiveTotal = sum(sorted_lfmut)
cumulative_lf = [sum(sorted_lfmut[0:k+1])/positiveTotal for k in range(len(sorted_lfmut))]
plt.plot(range(len(sorted_lfmut)), cumulative_lf,
         color="lightseagreen")
plt.xlabel("Mutations sorted by LFmut")
plt.ylabel("Cumulative positive LF")
plt.savefig(figPath + model_name + "_LFcumulative_positive.png",
            dpi=300)
plt.close()

# LF ~ phenotypic effect size
plt.plot(abs(mut_effect), delta_LF_mut,
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.1)
plt.xlabel("|Phenptypic effect size|")
# plt.ylabel("$LF_{mutation}$ (ln)")
plt.ylabel("$LF_{mutation}$")
# plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
#             dpi=100)
plt.savefig(figPath+model_name+"continuousWF_localAdapt_phenoEffectAndLF.png",
            dpi=300)
plt.close()

# LF ~ allele age
#np.seterr(divide = 'ignore')
plt.figure(1)
plt.plot(tempx_log, tempy_log,
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.1,
         label="Spearman's rho: "+str(spr)+"\n" + "p-value: 2.66e-22")
# plt.plot(tempx_log, res.intercept + tempy_log*res.slope,
#          color = "cornflowerblue")
# plt.axline((0,res.intercept),
#            slope=res.slope, color="cornflowerblue",
#            label = "")
# plt.title("With local adapation")
plt.xlabel("Mutation age (ln)")
plt.ylabel("$LF_{mutation}$ (ln)")
#plt.xscale("linear")
#plt.yscale("linear")
plt.savefig(figPath+model_name+"continuousWF_localAdapt_ageAndLF_ln.png",
            dpi=300)
plt.close()




#### cor Freq-Env as a proximation of GEA
# Divide the population into 10x10 sample-populations, for each sample population,
# calculate the correlation between allele frequency of each mutation and average local environmental variable(optimal)
# Assign samplePop id of each individual
num_samplePop = 100
samplePop = []
for i in ts.individuals():
    samplePop.append(int(i.location[0]/0.1)+int(i.location[1]/0.1)*10)
samplePop = np.array(samplePop)


# Get individual IDs of each sample population,
# also calculate the environmental optimal of each population, using the position of all local samples
indiv_samplePop = {}
env_samplePoP = np.zeros(num_samplePop)
freq_samplePop = np.zeros(shape=(ts.num_sites, num_samplePop))
for pop in np.arange(num_samplePop):
    indiv_samplePop[pop] = np.where(samplePop == pop)[0]
    env_samplePoP[pop] = (np.mean(ts.individuals_location[indiv_samplePop[pop]][:, 0]))
    # Calculate the derived allele frequency of all functional mutations in focal population
    j = 0
    for v in ts.variants(samples=indiv_samplePop[pop]):
        freq = sum(v.genotypes)/len(indiv_samplePop[pop])
        freq_samplePop[j][pop] = freq
        j += 1

# Correlation between allele frequency and environmental optima
# (np.corrcoef returns a matrix)
cor_GE = np.zeros(shape=(2, ts.num_sites))
for i in np.arange(ts.num_sites):
    if sum(freq_samplePop[i]) > 0:
        # correlation coefficient
        # cor_GE[0][i] = stats.spearmanr(freq_samplePop[i],env_samplePoP)[0]
        cor_GE[0][i] = stats.kendalltau(freq_samplePop[i], env_samplePoP)[0]
        # p-value
        # cor_GE[1][i] = stats.spearmanr(freq_samplePop[i], env_samplePoP)[1]
        cor_GE[1][i] = stats.kendalltau(freq_samplePop[i], env_samplePoP)[1]
    else:
        cor_GE[0][i] = float('nan')
        cor_GE[1][i] = float('nan')



plt.scatter(cor_GE[1], delta_LF_mut,
         marker="o",
         c=age, alpha=0.2)
plt.xlabel("cor_GE p-values")
plt.ylabel("delta_LF_mut")
plt.colorbar()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_ageColor.png",
            dpi=300)
plt.close()

# plt.scatter(cor_GE[0], delta_LF_mut,
#          marker="o",
#          c=age, alpha=0.2)
# plt.xlabel("cor_GE p-values")
# plt.ylabel("delta_LF_mut")
# plt.colorbar()
#
# plt.savefig(figPath+model_name+"_corGEcoef_vs_LF_mut_ageColor.png",
#             dpi=300)
# plt.close()

# Check the mutation with largest LF_mut
np.argmax(delta_LF_mut)
freq_samplePop[8]

