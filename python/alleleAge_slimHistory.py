"""Explore how the performance of GEA is affected by allele ages and how this
effect interact with demographic history,
using tree sequences generated by CONTINUOUS SPACE nonWF models in SLiM
Compared to alleleAge.py:
    Neutral mutations are added after SLiM simulations at a rate of 5e-8
    (3.75e-8, Ingvarsson 2008, doi: 10.1534/genetics.108.090431.)
tianlin.duan42@gmail.com
2024.03.22
"""
############################# modules #########################################
import msprime
import tskit
import pyslim
import matplotlib.pyplot as plt
import scipy.stats as stats
from scipy.spatial import distance_matrix
import numpy as np
import random
from time import time
import sys # for sys.exit()
import allel # for allel.weir_cockerham_fst()
import os # mkdir

############################# options #############################
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('-t', '--tree',
                    # may contain the relative path to the file
                    # if the path differs from and is inside the inPath below
                    help='Base name of the tree file from SLiM',
                    type=str)
parser.add_argument('-p', '--plot',
                    help='1 for generating plots and 0 for not plotting',
                    type=int, default=1)
args = parser.parse_args()

############################# functions #######################################
def tree_heights(treeSequences):
    kb = [0]
    mrca_t = []
    for tree in treeSequences.trees():
        kb.append(tree.interval.right / 1000)
        if tree.has_multiple_roots:
            # Use the maximum time when not coalesced
            mrca_t.append(treeSequences.metadata["SLiM"]["tick"])
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            mrca_t.append(tree.time(real_root))
    return mrca_t, kb

def tree_height(tree, max_tick):
    if tree.has_multiple_roots:
        # Use the maximum time when not coalesced
        tmrca = (max_tick)
    else:
        children = tree.children(tree.root)
        real_root = tree.root if len(children) > 1 else children[0]
        tmrca = (tree.time(real_root))
    return tmrca

def LF_fitness_loop(ind_x, ind_y, phenotype, optima, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        optima of the localtion of each individual(array-like),
        a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return an array of the difference of average fitness of local and foreign individuals.
    v1: memory efficient but not time efficient
    """
    w_foreign = []
    w_local = []
    for i in range(len(ind_x)):
        dist = np.sqrt((ind_x - ind_x[i]) ** 2 + (ind_y - ind_y[i]) ** 2)
        w_all = 1.0 + stats.norm.pdf(phenotype, optima[i], sigma_w)
        w_relative = np.array(w_all / np.mean(w_all))
        w_foreign.append(np.mean(w_relative[dist > dist_mate]))
        w_local.append(np.mean(w_relative[dist <= dist_mate]))
    return np.array(w_local), np.array(w_foreign)

def LF_fitness(ind_x, ind_y, phenotype,
               optima, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        environmental optima (array-like), a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return two arrays of the average fitness of local and foreign individuals, respectively.
    v2: time efficient but not memory efficient.
    Try the other version when the number of individuals is large.
    """
    optima=np.array(optima)
    coord = list(zip(ind_x, ind_y))
    dist_matrix = distance_matrix(coord, coord)
    isLocal_matrix = dist_matrix <= dist_mate
    # Calculate fitness matrix (w_matrix[i][j]: individual j at location i) with broadcast
    w_matrix = 1.0 + stats.norm.pdf(np.array(phenotype),
                                    np.array(optima)[:, np.newaxis],
                                    sigma_w)
    # relative fitness
    w_matrix = w_matrix / np.mean(w_matrix, 1)[:, np.newaxis]
    #Average relative fitness of local and foreign individuals
    w_local = np.mean(np.ma.masked_array(w_matrix, np.invert(isLocal_matrix)), 1)
    w_foreign = np.mean(np.ma.masked_array(w_matrix, isLocal_matrix), 1)
    return w_local, w_foreign

############################# program #########################################
# Values
sigma_w = 0.4
# sigma_w = 1.0
# sigma_w = 2.0
dist_mate = 0.15

#User input arguments:
relative_path_file_name = args.tree
# Remove paths
model_name = relative_path_file_name.split("/")[-1]
file_name = relative_path_file_name+".trees"

#M2b
# model_name = "Continuous_nonWF_M2b_mu1.0e-09_sigmaM0.4_sigmaW0.4_seed4211585214153878784_tick20000"
# model_name = "Continuous_nonWF_M2b_mu1.0e-09_sigmaM0.4_sigmaW0.4_seed4211585214153878784_tick10400"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed2186716867923388027_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.1_seed2805110583194452015_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.4_seed1207239118116064755_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.01_sigmaW2.0_seed674562876216857337_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.4_seed420342970716621951_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.4_seed4094191535017385840_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.01_sigmaW1.0_seed41659979142462089_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-08_sigmaM0.001_sigmaW1.0_seed3792290627629629913_tick14000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-08_sigmaM0.001_sigmaW4.0_seed1214813491260327418_tick14000"


#Set 1: sigmaM0.1, sigmaW2.0
#M0a
# model_name = "Continuous_nonWF_M0a_mu1.0e-09_sigmaM0.1_seed159493640993233401_tick20000"
#M0b
# model_name = "Continuous_nonWF_M0b_neutralHistory_mu1.0e-09_sigmaM0.1_seed4262922979799227249_tick20000"
#M1a
# model_name = "Continuous_nonWF_M1a_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed2043775523926582509_tick20000"
#M1b
# model_name = "Continuous_nonWF_M1b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed1704698170862545749_tick20000"
#M2a
# model_name = "Continuous_nonWF_M2a_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed432632840517966805_tick20000"
#M2b
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed443882937971756522_tick20000"


# For polygenic level
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-08_sigmaM0.01_sigmaW0.4_seed4558024080115874106_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.02_mateD0.1_seed2644576448062051676_tick10000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.02_mateD0.1_seed2576810709553405081_tick10000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.02_mateD0.1_seed752867212612127483_tick400"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.02_mateD0.1_seed752867212612127483_tick10000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.02_mateD0.1_seed2630909755192467016_tick400"


# For lower Fst
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-08_sigmaM0.01_sigmaW0.4sigmaD0.1_mateD0.2_seed589982169230488297_tick20000"

# Environmental optima data added
# model_name = "Continuous_nonWF_M2b_msprimeHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.02_mateD0.1_seed1182060949244852873_tick10000"
# model_name = "Continuous_nonWF_M2b_msprimeHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.02_mateD0.1_seed1182060949244852873_tick400"
# model_name = "Continuous_nonWF_M2a_msprimeHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.02_mateD0.1_seed875191216119940727_tick100"
# model_name = "Continuous_nonWF_M2a_msprimeHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.02_mateD0.1_seed875191216119940727_tick400"
# model_name = "Continuous_nonWF_M2a_msprimeHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.02_mateD0.1_seed875191216119940727_tick10000"
# model_name = "Continuous_nonWF_M2b_msprimeHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.1_mateD0.2_seed2135186399283767611_tick400"
# model_name = "Continuous_nonWF_M2b_msprimeHistory_mu1.0e-08_r1.0e-07_sigmaM0.01_sigmaW0.4_sigmaD0.1_mateD0.2_seed2135186399283767611_tick10000"


# Test "no standing variation problem"
# model_name = "Continuous_nonWF_M2a_msprimeHistory_mu1.0e-09_r1.0e-07_sigmaM0.1_sigmaW0.4_sigmaD0.02_mateD0.1_seed1455097569078309823_tick100"

# Test glacial model
# model_name = "Continuous_nonWF_M2b_glacialHistory_mu1.0e-08_sigmaM0.01_sigmaW0.4_seed4459818163778896215_tick110000"
# model_name="Continuous_nonWF_M2b_glacialHistory_mu1.0e-08_sigmaM0.01_sigmaW0.4_seed3619471502973802965_tick100800"

# inPath = "/home/tianlin/Documents/github/data/slim_data/"
# inPath = "/home/tianlin/Documents/github/data/slim_data/m2b_mu1e-7_m0.1_w0.4/test/"
# inPath = "/home/tianlin/Documents/github/data/slim_data/glacial_history/highPoly_highMig_clineMap/"
# inPath = "/home/tianlin/Documents/github/data/slim_data/glacial_history/highPoly_middleMig_patchyMap/"
inPath = "/home/tianlin/Documents/github/data/slim_data/glacial_history/M0b_highPoly_highMig/"
# figPath = "/home/tianlin/Documents/github/data/tskit_data/figure/"
figPath = "/home/tianlin/Documents/github/data/tskit_data/figure/20240419/"
# outPath = "/home/tianlin/Documents/github/data/tskit_data/output/"
# outPath = "/home/tianlin/Documents/github/data/tskit_data/output/Continuous_nonWF_M2b_glacialHistory_mu1.0e-08_sigmaM0.01_sigmaW0.4_sigmaD0.1_mateD0.2/"
outPath = "/home/tianlin/Documents/github/data/tskit_data/output/Continuous_nonWF_M0b_glacialHistory_mu1.0e-08_sigmaM0.01_sigmaW0.4_sigmaD0.06_mateD0.15/"
# current_tick = int(model_name.split("_")[-1][4:]) # hard coded for a specific name pattern, not ideal
history = 100000 # number of generations before the focal model

# Tree-sequence file from SLiM
ts = tskit.load(inPath + file_name)
current_tick = ts.metadata['SLiM']['tick']
ind_x, ind_y, ind_z = zip(*ts.individuals_location)
# Genomic position of sites
pos = ts.sites_position
# Genomic position of mutations
pos_by_mut = ts.sites_position[ts.mutations_site]
# Maximum tick
max_tick = ts.metadata["SLiM"]["tick"]
# Number of diploid individuals
N = ts.num_individuals
# Environmental optima
optima = np.array(ts.metadata['SLiM']['user_metadata']['indsOptimum'])
mapValues = np.array(ts.metadata['SLiM']['user_metadata']['mapValues'])

# Recapitation: better skipped as no functional mutation was added during this stage
ts_recap = pyslim.recapitate(ts, ancestral_Ne=5e3,
                             recombination_rate=1e-7,
                             random_seed=1)

(tmrca_recap, kb_recap) = tree_heights(ts_recap)

# Add neutral mutations
mutation_seed = random.randint(1, 2**31)
mut_model1 = msprime.SLiMMutationModel(type=1)
mts = msprime.sim_mutations(ts_recap,
                            rate=5e-8,
                            random_seed=mutation_seed,
                            model=mut_model1,
                            keep=True) #keep the existing mutations

# Phenotypic effect of each mutation
# 1-dimensional
mut_effect = []
for mut in mts.mutations():
    mut_effect.append(mut.metadata['mutation_list'][0]['selection_coeff'])
mut_effect = np.array(mut_effect)

# 2-dimensional: list of lists, corresponding to phenotypic effect of allele 0/1/2... at each site
mut_effect_lists = []
for site in mts.sites():
    effect_site = [0]
    for mut in site.mutations:
        effect_site.append(mut.metadata['mutation_list'][0]['selection_coeff'])
    mut_effect_lists.append(effect_site)

# Observed extent of local adaptation (local-foreign contrast (LF))
(w_local, w_foreign) = LF_fitness(ind_x, ind_y, ind_z,
                                  optima, dist_mate, sigma_w)
LF_cline = w_local - w_foreign
mean_LF = np.mean(LF_cline)
# Overall extent of local adaptation
#print(mean_LF)


# Contribution of each mutation to LF
# Version 2: randomizing the distribution of the mutation
# Skip calculation for neutral mutations
shuffle_replicates = 1
LF_shuffle = []
t = time()
index_site = 0
# traverse sites with mutations
for v in mts.variants():
    # Skip calculation and directly append mean_LF as LF_shuffle
    # By definition neutral mutations should not affect phenotypes at all
    if sum(mut_effect_lists[index_site]) == 0:
        index_gt = 1
        while index_gt < len(mut_effect_lists[index_site]):
            LF_shuffle.append(mean_LF)
            index_gt += 1
    else:
        # Calculate the effect of each mutation at the focal site
        index_gt = 1
        # traverse all derived alleles at the site
        while index_gt < len(mut_effect_lists[index_site]):
            # for multiallelic sites, hide other alleles at the site except the focal allele,
            # leave only one allele at each time
            focal_gt = np.array(v.genotypes)
            focal_gt[focal_gt != index_gt] = 0
            # effect of the focal mutation in each individual
            effect_mut_genomes = np.array(mut_effect_lists[index_site])[focal_gt]
            # Add up the two genomes of each individual
            effect_mut_ind = (effect_mut_genomes[range(0, 2 * N - 1, 2)] +
                              effect_mut_genomes[range(1, 2 * N, 2)])
            phenotype_without_mut = ind_z - effect_mut_ind
            # Shuffle the distribution of the individuals
            # (without changing the observed heterozygosity)
            r = 0
            LF_shuffle_mut = np.zeros(shuffle_replicates)
            while r < shuffle_replicates:
                effect_mut_ind_shuffle = list(effect_mut_ind)  # shallow copy
                np.random.shuffle(effect_mut_ind_shuffle)
                # print(list(effect_mut_ind))
                # print(effect_mut_ind_shuffle)
                # Phenotype with shuffled mut =
                # phenotypes of each ind - effect of the focal mutation in each ind
                # + effect of the focal mutation in each ind after shuffling
                phenotype_shuffle = phenotype_without_mut + effect_mut_ind_shuffle
                (w_local, w_foreign) = LF_fitness(ind_x, ind_y, phenotype_shuffle,
                                                  optima, dist_mate, sigma_w)
                LF_shuffle_mut[r] = np.mean(w_local - w_foreign)
                r += 1
            LF_shuffle.append(np.mean(LF_shuffle_mut))
            index_gt += 1
    index_site += 1
    if index_site % 10000 == 0:
        print(f"{index_site} sites processed")
delta_LF_mut = mean_LF-LF_shuffle
# Elapsed Time
timer = time() - t
print(timer/60)
# for 1 replicate, 373377 neutral sites and 200 functional sites take 4 minutes
# for 1 replicate, 333977 neutral sites and 200 functional sites take 28 minutes

# # Save the contribution of each mutation to LF
# with open(outPath+model_name + "delta_LF_shuffle" +
#           str(shuffle_replicates) + "_withNeutralMut_mutSeed" +
#           str(mutation_seed) + ".txt", "w") as fout:
#     for item in delta_LF_mut:
#         fout.write(str(item) + "\n")
# fout.close()
#
# # Load LF from file
# delta_LF_mut = np.loadtxt(outPath+model_name + "delta_LF_shuffle" +
#           str(shuffle_replicates) + "_withNeutralMut_mutSeed" +
#           str(mutation_seed) + ".txt")

# Age of each mutation
age = mts.mutations_time
pos_by_mut = mts.sites_position[mts.mutations_site]

# Mutation effects by mutation coordinates
effect_by_mut = np.full(shape=mts.num_mutations,
                        fill_value=np.nan)

effect_by_mut = []
for site in mts.sites():
    for mut in site.mutations:
        effect_by_mut.append(mut.metadata['mutation_list'][0]['selection_coeff'])
effect_by_mut = np.array(effect_by_mut)

# Frequency of each mutation
freq = []
num_samples = mts.num_samples
for v in mts.variants():
    for allele in np.arange(1, v.num_alleles):
        focal_freq = np.count_nonzero(v.genotypes == allele)/num_samples
        freq.append(focal_freq)

# TMRCA of all samples at the position of each mutation
# # t0 = time()
# t0 = time()
# tmrca_mut = []
# for p in pos_by_mut:
#     tmrca_mut.append(tree_height(mts.at(p), max_tick))
# timer = time() - t0
# print(timer)

tmrca_mut = np.full(shape=mts.num_mutations,
                    fill_value=np.nan)
i = 0
for p in pos_by_mut:
    tmrca_mut[i] = tree_height(mts.at(p), max_tick)
    i += 1

# Remove negative LF values and 0 allele age for some plots
age_positveLFandAge = age[np.logical_and(delta_LF_mut > 0, age > 0)]
delta_LF_mut_positveLFandAge = delta_LF_mut[np.logical_and(delta_LF_mut > 0,
                                                           age > 0)]
age_positveLFandAge_log = np.log(age_positveLFandAge)
delta_LF_mut_positveLFandAge_log = np.log(delta_LF_mut_positveLFandAge)

#### cor Freq-Env as a proximation of GEA
# Divide the population into 10x10 subpopulations, for each subpopulation,
# calculate the correlation between allele frequency of each mutation
# and average local environmental variable(optima)
# Assign a two-digit subpop id for each individual
# |90|91|92|93|94|95|96|97|98|99|
# ...
# |20|21|22|23|24|25|26|27|28|29|
# |10|11|12|03|14|15|16|17|18|19|
# |00|01|02|03|04|05|06|07|08|09|
map_width = 1.0
map_height = 1.0
# Only works when both num_row and num_col <= 10
num_row = 10
num_col = 10
num_sample_pop = num_row * num_col
sample_pop_ids = np.full(fill_value=np.nan,
                         shape=mts.num_individuals)
i = 0
for ind in mts.individuals():
    x = int(ind.location[0]/(map_width/num_row))
    y = int(ind.location[1]/(map_width/num_col))
    # Push the ones on the upper boundaries back
    x = x if x < num_row else (num_row-1)
    y = y if y < num_col else (num_col-1)
    sample_pop_ids[i] = x+y*10
    i += 1

np.unique(sample_pop_ids, return_counts=True)
# # Check the sample size of the grids
# plt.hist(sample_pop_ids, bins=100,
#          color="grey")
# plt.savefig(figPath+model_name+"_subsample_size.png",
#             dpi=300)
# plt.close()

# A collection of individual IDs for each subpopulation
inds_subpop = {}
# A collection of genome IDs for each subpopulation
genome_subpop = {}
# Average environmental optima of each sample population,
# calculated by the position of all local individuals
env_sample_pop = np.full(fill_value=np.nan,
                         shape=num_sample_pop)
# A vector of allele frequencies of all mutations for each sample population
freq_sample_pop = np.full(fill_value=np.nan,
                          shape=(mts.num_mutations, num_sample_pop))
for focal_pop_id in np.arange(num_sample_pop):
    focal_ind_list = np.array(np.where(sample_pop_ids == focal_pop_id)[0])
    focal_genome_list = np.stack((focal_ind_list*2,
                                  focal_ind_list*2+1)).ravel('F')
    inds_subpop[focal_pop_id] = focal_ind_list
    genome_subpop[focal_pop_id] = focal_genome_list
    # A special map: local env optima = x coordinates of local samples
    # env_sample_pop[focal_pop_id] = np.mean(mts.individuals_location[focal_ind_list][:, 0])
    #General form of optima
    env_sample_pop[focal_pop_id] = np.mean(optima[focal_ind_list])
    # Calculate derived allele frequency of each mutation in focal population
    index_site = 0
    index_mut = 0
    for v in mts.variants(samples=focal_genome_list):
        index_gt = 1
        # traverse all derived alleles at the site
        while index_gt < len(mut_effect_lists[index_site]):
            # if index_mut == 10000:
            #     test2 = v
            # print(v.genotypes)
            derived_freq = np.count_nonzero(v.genotypes==index_gt)/len(focal_genome_list)
            # print(len(focal_ind_list))
            # print(v.frequencies())
            # print(derived_freq)
            freq_sample_pop[index_mut][focal_pop_id] = derived_freq
            index_gt += 1
            index_mut += 1
        index_site += 1

# Correlation between allele frequency and environmental optima
# correlation coefficient and p-value
cor_GE = np.full(fill_value=np.nan,
                 shape=(2, mts.num_mutations))
for i in np.arange(mts.num_mutations):
    # skipped fixed/lost mutations
    if sum(freq_sample_pop[i]) > 0:
        # position 0: correlation coefficients, position 1: p-values
        # (cor_GE[0][i], cor_GE[1][i]) = stats.spearmanr(freq_sample_pop[i],
        #                                                env_sample_pop)
        (cor_GE[0][i], cor_GE[1][i]) = stats.kendalltau(freq_sample_pop[i],
                                                        env_sample_pop)

# p-value adjusted by the Benjamini-Hochberg method
# temporarily remove nan values
p_mask = np.isnan(cor_GE[1])
p_no_nan = cor_GE[1][~p_mask]
p_BH_no_nan = stats.false_discovery_control(p_no_nan)
p_BH = np.full(shape=len(cor_GE[1]), fill_value=np.nan)
p_BH[~p_mask] = p_BH_no_nan

# True positive rate, False negative rate, False discovery rate
# True adaptive allele: account for more than LF_min percent of positve LF_mut
# GEA significant: BH-adjusted p-value < 0.05
LF_positive = sum(delta_LF_mut[delta_LF_mut>0])
LF_min = 0.01
num_cat = 10
cat_width = int(100/num_cat) if 100 % num_cat == 0 else 100/num_cat
age_percentile = np.percentile(age,
                               np.append(np.arange(0, 100, cat_width),100))
TPR = []
FPR = []
FDR = []
for i in range(num_cat):
    # p_category = cor_GE[1][np.logical_and(age > age_percentile[i],
    #                                   age <= age_percentile[i+1])]
    p_BH_category = p_BH[np.logical_and(age > age_percentile[i],
                                      age <= age_percentile[i+1])]
    delta_LF_mut_category = delta_LF_mut[np.logical_and(age > age_percentile[i],
                                      age <= age_percentile[i+1])]
    # num_allele = len(p_BH_category)
    # proportion_sig.append(sum(p_BH_category < 0.05)/num_allele)
    expP = delta_LF_mut_category > LF_min*LF_positive
    obsP = p_BH_category < 0.05
    TP = sum(expP & obsP)
    FP = sum(~expP & obsP)
    FN = sum(expP & ~obsP)
    TN = sum(~expP & ~obsP)
    TPR.append(TP/(TP+FN))
    FPR.append(FP/(TN+FP))
    FDR.append(FP/(TP+FP))


#### Save the data table: quite large, perhaps not a good idea
# mutation ID, allele age, allele frequency, mutation effect, LF_mut,
# GEA Kendall's tau and corresponding p-value
myTable = np.array([np.arange(mts.num_mutations),
                    age,
                    freq,
                    mut_effect,
                    delta_LF_mut,
                    cor_GE[0],
                    cor_GE[1]])
np.savetxt(outPath + model_name + "_withNeutralMut_mutSeed" +
           str(mutation_seed) + "_table.txt",
           myTable,
           header="ID, allele_age, allele_freq, effect_size, lf_mut, tau, p")

# Fst
g = mts.genotype_matrix().reshape(mts.num_sites, mts.num_individuals, 2)
subpops = [inds_subpop[i] for i in range(100)]
a, b, c = allel.weir_cockerham_fst(g, subpops)
fst_pop = a / (a + b + c)
fst = np.sum(a) / (np.sum(a) + np.sum(b) + np.sum(c))
print(fst)


#### Plots ####
# # Skip the following lines and end the program if "--plot" is 0
# if not bool(args.plot):
#     print("Program finished. No plot will be generated as --plot is 0.")
#     sys.exit(0)

#Path for the current run
figPath = figPath + model_name+ "_fst_" + str(round(fst,4)) +"/"
os.mkdir(figPath)

# Display the average fitness of local and foreign populations
plt.figure(1)
plt.boxplot([w_local, w_foreign],
            labels=["Local", "Foreign"])
plt.xlabel("Groups")
plt.ylabel("Average relative fitness")
# plt.show()
plt.savefig(figPath + str(model_name) + "_test_localAdapt.png",
            dpi=300)
plt.close()

# Histogram of non-0 LF_mut
plt.hist(delta_LF_mut[delta_LF_mut != 0], bins=100,
         color="grey")
plt.xlabel("$LF_{mut}$")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_non0LFhist.png",
            dpi=300)
plt.close()

# # Histogram of positive LF
# plt.hist(delta_LF_mut[delta_LF_mut > 0], bins=100,
#          color="grey")
# # plt.title("With local adapation")
# plt.xlabel("$LF_{mut}$")
# plt.ylabel("Count")
# plt.savefig(figPath+model_name+"_LFhist_positive.png",
#             dpi=300)
# plt.close()

# Cumulative plot of LF_mut
expected_explained_proportion = 0.8
sorted_lfmut = np.array(list(reversed(sorted(delta_LF_mut_positveLFandAge))))
positiveTotal = sum(sorted_lfmut)
cumulative_lf = [0] + [sum(sorted_lfmut[0:k+1])/positiveTotal
                       for k in range(len(sorted_lfmut))]
# How many alleles do we need to account for 80% of current local adaptation?
gea_goal = sum(np.array(cumulative_lf) < expected_explained_proportion)
explained = cumulative_lf[gea_goal]
plt.plot(range(len(sorted_lfmut)+1), cumulative_lf,
         color="lightseagreen")
plt.xlabel("Mutations sorted in descending order of $LF_{mut}$")
plt.ylabel("Cumulative proportion of positive LF")
# plt.axvline(x=gea_goal, color="firebrick", linestyle="dotted")
# plt.axhline(y=explained, color="firebrick", linestyle="dotted")
plt.plot([gea_goal, gea_goal], [0, explained],
         color="firebrick", linestyle="dotted")
plt.plot([0, gea_goal], [explained, explained],
         color="firebrick", linestyle="dotted")
plt.annotate(str(gea_goal), xy=(gea_goal+1, explained),
             xytext=(gea_goal + 1 + len(cumulative_lf)/40, 0),
             color="firebrick")
plt.savefig(figPath + model_name + "_LFcumulative_positive.png",
            dpi=300)
plt.close()

# # LF ~ phenotypic effect size
# plt.plot(abs(mut_effect), delta_LF_mut,
#          marker="o", linestyle="",
#          color="saddlebrown", alpha=0.1)
# plt.xlabel("|Phenptypic effect size|")
# # plt.ylabel("$LF_{mutation}$ (ln)")
# plt.ylabel("$LF_{mutation}$")
# # plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
# #             dpi=100)
# plt.savefig(figPath+model_name+"continuousWF_phenoEffectAndLF.png",
#             dpi=300)
# plt.close()

# LF ~ |phenotypic effect size|
age_rank_bin = (age.argsort().argsort()/10000).astype(int)
plt.scatter(abs(mut_effect), delta_LF_mut,
            marker="o",
            c=age_rank_bin, alpha=0.2)
plt.xlabel("|Phenotypic effect size|")
plt.ylabel("$LF_{mut}$")
plt.colorbar().set_label("Age rank bins \n (10000 alleles per bin)")
plt.tight_layout()
plt.savefig(figPath+model_name+"_phenoEffectAndLF_ageRankColor.png",
            dpi=300)
plt.close()



# total LF of the size ~ |phenotypic effect size|
# total LF of the size ~ |phenotypic effect size|, separating positive and negative parts

num_cat = 10 # Number of categories for allele age
abs_effect = abs(mut_effect)
LF_total = sum(delta_LF_mut)
LF_positive = sum(delta_LF_mut[delta_LF_mut>0])
LF_negative = sum(delta_LF_mut[delta_LF_mut<0])
lf_sum = []
lf_sum_positive = []
lf_sum_negative = []
alpha_cats = np.append(np.arange(0, max(abs_effect), max(abs_effect)/num_cat),
                       max(abs_effect))
for i in range(num_cat):
    lf_category = delta_LF_mut[np.logical_and(abs_effect > alpha_cats[i],
                                              abs_effect <= alpha_cats[i+1])]
    lf_sum.append(sum(lf_category/LF_total))
    lf_sum_positive.append(sum(lf_category[lf_category > 0]) / LF_total)
    lf_sum_negative.append(sum(lf_category[lf_category < 0]) / LF_total)

#total LF of the size ~ |phenotypic effect size|
plt.figure(1)
plt.plot(alpha_cats[1:],
         lf_sum,
         color="grey")
plt.xlabel("|Mutation phenotypic effect size|")
plt.ylabel("Relative contribution to local adaptation from the size class")
# plt.xticks(ticks=np.arange(100/num_cat, 101, 100/num_cat),
#            labels=[(str(i*cat_width)+"-"+str((i+1)*cat_width))
#                    for i in range(num_cat)])
plt.tight_layout()
plt.savefig(figPath+model_name+"_"+str(num_cat) + "bins"+
            "_LF_by_absEffectSize_bin.png",
            dpi=300)
plt.close()

# total LF of the size ~ |phenotypic effect size|, separated by positive and
# negative contributions
plt.figure(1)
lf_sum_positive = np.array(lf_sum_positive)
lf_sum_negative = np.array(lf_sum_negative)
x = alpha_cats[1:]
y1 = lf_sum_positive
y2 = lf_sum_negative
fig, ax = plt.subplots()
ax.plot(x, y1, color="mediumaquamarine",
        label="Positive")
ax.plot(x, y2, color="saddlebrown",
        label="Negative")
ax.axhline(0, color='grey', lw=1, dashes=(1,1))
plt.xlabel("|Mutation phenotypic effect size|")
plt.ylabel("Relative contribution to local from the size class")
ax.legend(loc="upper right")
ax.yaxis.set_major_formatter(lambda x, pos: f'{abs(x):g}')
ax.margins(x=0)
plt.savefig(figPath+model_name+"_"+str(num_cat) + "bins"+
            "_LF_by_absEffectSize_bin_positveAndnegative.png",
            dpi=300)
plt.close()


# Relative LF_mut by pos
fig, axs = plt.subplots(2, 1)
fig.set_figheight(9)
fig.set_figwidth(9)
LF_positive = sum(delta_LF_mut[delta_LF_mut>0])
# plot 0: TMRCA with the contribution of sites to local adaptation (delta LF)
# axs[0].stairs(tmrca_recap, kb_recap, baseline=None,
#            color="mediumaquamarine")
axs[0].plot(pos_by_mut/1000, delta_LF_mut/LF_positive,
         marker="o", linestyle="",
         color="mediumaquamarine", alpha=0.2)
# axs[0].set_title("$LF_{mutation}$")
# axs[0].set_xlabel("Genomic positions (kb)")
axs[0].set_ylabel("$LF_{mutation}$")
# axs[1].stairs(tmrca_recap, kb_recap, baseline=None,
#            color="mediumaquamarine")
axs[1].plot(pos_by_mut/1000, -np.log10(cor_GE[1]),
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.05)
# axs[1].set_title("-log10(p-value)")
axs[1].set_xlabel("Genomic positions (kb)")
axs[1].set_ylabel("-log10(p-value)")
plt.savefig(figPath+model_name+"_lfmut_gea_by_pos.png",
            dpi=300)
plt.close()

# # positive LF ~ allele age
# tempx = age_positveLFandAge_log
# tempy = delta_LF_mut_positveLFandAge_log
# res = stats.linregress(tempx, tempy)
# rsquared = round(res.rvalue ** 2, 3)
# linearp = '{:0.2e}'.format(res.pvalue)
# spr = stats.spearmanr(age, delta_LF_mut)
# spr_positive = stats.spearmanr(age_positveLFandAge, tempy)
#
# plt.figure(1)
# plt.plot(tempx, tempy,
#          marker="o", linestyle="",
#          color="saddlebrown", alpha=0.1)
# plt.plot(sorted(tempx),
#          res.intercept + np.array(sorted(tempx))*res.slope,
#          color = "cornflowerblue")
# plt.text(0, min(tempy)+(max(tempy)-min(tempy))*0.9,
#          "$r^{2}$="+str(rsquared)+"\n" + "p-value=" + str(linearp),
#          color = "cornflowerblue")
# # plt.axline((0,res.intercept),
# #            slope=res.slope, color="cornflowerblue",
# #            label = "")
# # plt.title("With local adapation")
# plt.xlabel("ln(Mutation age)")
# plt.ylabel("ln(Positive $LF_{mut})$")
# plt.savefig(figPath+model_name+"_ageAndLF_ln.png",
#             dpi=300)
# plt.close()

# # non-0 |LF| ~ allele age
# tempx = np.log(age[np.logical_and(delta_LF_mut != 0, age != 0)])
# tempy = np.log(np.abs(delta_LF_mut[np.logical_and(delta_LF_mut != 0, age != 0)]))
# res = stats.linregress(tempx, tempy)
# rsquared = round(res.rvalue ** 2, 3)
# slope = '{:0.2e}'.format(res.slope)
# linearp = '{:0.2e}'.format(res.pvalue)
# spr_abs = stats.spearmanr(tempx, tempy)
# plt.figure(1)
# plt.plot(tempx, tempy,
#          marker="o", linestyle="",
#          color="saddlebrown", alpha=0.1)
# plt.plot(sorted(tempx),
#          res.intercept + np.array(sorted(tempx))*res.slope,
#          color = "cornflowerblue")
# plt.text(0, min(tempy)+(max(tempy)-min(tempy))*0.9,
#          "$r^{2}$="+str(rsquared) + "\n" +
#          "P-value=" + str(linearp) + "\n" +
#          "Slope=" + str(slope),
#          color = "cornflowerblue")
# plt.xlabel("ln(Mutation age)")
# plt.ylabel("ln(|$LF_{mut})$|")
# plt.savefig(figPath+model_name+"_non0ageAndAbsoluteNon0LF_ln.png",
#             dpi=300)
# plt.close()



# Histogram of GEA p-values
plt.hist(cor_GE[1], bins=100,
         color="grey")
plt.xlabel("GEA p-values")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_GEA_pvalue_hist.png",
            dpi=300)
plt.close()

# Histogram of allele age
plt.hist(age, bins=100,
         color="grey")
plt.xlabel("Allele age")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_age_hist.png",
            dpi=300)
plt.close()

# Histogram of raw GEA p-values by allele age
# Also calculate the proportion of significant (FDR < 0.05) alleles in each age category,
# using p-values adjusted with Benjamini-Hochberg method
num_cat = 10
age_percentile = np.percentile(age, np.append(np.arange(0, 100, num_cat),100))
# k = 0
proportion_sig = []
for i in range(num_cat):
    # k += len(cor_GE[1][np.logical_and(age > age_percentile[i],
    #                                   age <= age_percentile[i+1])])
    p_category = cor_GE[1][np.logical_and(age > age_percentile[i],
                                      age <= age_percentile[i+1])]
    p_BH_category = p_BH[np.logical_and(age > age_percentile[i],
                                      age <= age_percentile[i+1])]
    num_allele = len(p_category)
    # proportion_sig.append(sum(p_BH_category < 0.05)/num_allele)
    proportion_sig.append(sum(p_category < 0.05) / num_allele)
    plt.hist(p_category,
             bins=100,
             color="grey")
    plt.xlabel("GEA p-values")
    plt.ylabel("Count")

    plt.title("Bin " + str(i) + ": \n " +
              "age " +str(int(age_percentile[i])) +
              "-" + str(int(age_percentile[i+1])))
    plt.savefig(figPath+model_name+"_GEA_pvalue_hist_byAge_bin"+str(i)+".png",
                dpi=300)
    plt.close()
# print(k)



# Proportion of significant alleles ~ age percentile bin
num_cat = 10
plt.plot(np.arange(100/num_cat, 110, 100/num_cat),
         proportion_sig,
         color="grey")
plt.xlabel("Allele age percentile bins")
# plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
plt.ylabel("Proportion of alleles with p-value < 0.05")
plt.xticks(ticks=np.arange(100/num_cat, 110, 100/num_cat),
           labels=[(str(i*10)+"-"+str(i*10+10)) for i in range(10)])
plt.savefig(figPath+model_name+"_proportionGEArawP_vs_age.png",
            dpi=300)
plt.close()


# # Histogram of GEA tau
# plt.hist(cor_GE[0], bins=100,
#          color="grey")
# plt.xlabel("GEA Kendall's tau")
# plt.ylabel("Count")
# plt.savefig(figPath+model_name+"_GEA_tau_hist.png",
#             dpi=300)
# plt.close()

# # GEA p-value ~ Allele age
# plt.scatter(age, cor_GE[1],
#          marker="o",
#          c="grey", alpha=0.05)
# plt.xlabel("Allele age")
# plt.ylabel("GEA p-values")
# # plt.colorbar().set_label("$LF_{mut}$")
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_GEApvalue_vs_age.png",
#             dpi=300)
# plt.close()

# # |GEA Kendall's tau| ~ Allele age
# plt.scatter(age, abs(cor_GE[0]),
#          marker="o",
#          c="grey", alpha=0.05)
# plt.xlabel("Allele age")
# plt.ylabel("|GEA Kendall's tau|")
# # plt.colorbar().set_label("$LF_{mut}$")
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_absGEATau_vs_age.png",
#             dpi=300)
# plt.close()

# # Allele frequency ~ Allele age
# plt.scatter(age, freq,
#          marker="o",
#          # c=cor_GE[1], alpha=0.05)
#          c="grey", alpha = 0.05)
# plt.xlabel("Allele age")
# plt.ylabel("Allele frequency")
# # plt.colorbar().set_label("GEA p-values")
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_freq_vs_age.png",
#             dpi=300)
# plt.close()


# Relative LF_mut ~ cor_GE p-values, colored by log10(age)
plt.scatter(cor_GE[1], delta_LF_mut/LF_positive,
            marker="o",
            c=np.log10(age), alpha=0.2)
plt.xlabel("GEA p-values")
plt.ylabel("Relative $LF_{mut}$")
plt.colorbar().set_label("log10(allele age)")
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_relativeLFmut_log10ageColor.png",
            dpi=300)
plt.close()

# Relative LF_mut ~ cor_GE p-values RANKS, colored by age rank bins
p_rank = cor_GE[1].argsort().argsort()
age_rank_bin = (age.argsort().argsort()/10000).astype(int)
plt.scatter(p_rank, delta_LF_mut/LF_positive,
         marker="o",
         c=age_rank_bin, alpha=0.2)
plt.xlabel("GEA p-values ranks")
plt.ylabel("Relative $LF_{mut}$")
plt.colorbar().set_label("Age rank bins \n (10000 alleles per bin)")
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalueRank_vs_relativeLFmut_ageBinColor.png",
            dpi=300)
plt.close()

# # Temperary test: Relative LF_mut ~ cor_GE p-values RANKS, only the oldest age bin
# p_rank = cor_GE[1].argsort().argsort()
# age_rank_bin = (age.argsort().argsort()/10000).astype(int)
# i = 32
# plt.scatter(p_rank[age_rank_bin == i],
#             (delta_LF_mut/LF_positive)[age_rank_bin == i],
#             marker="o", c="grey", alpha=0.2)
# plt.xlabel("GEA p-values ranks")
# plt.ylabel("Relative $LF_{mut}$")
# plt.title("Age bin 32")
# # plt.colorbar().set_label("Age rank bins \n (10000 alleles per bin)")
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_corGEpvalueRank_vs_relativeLFmut_ageBin32.png",
#             dpi=300)
# plt.close()

# By allele age bins
# Relative LF_mut ~ cor_GE p-values RANKS
num_cat = 10
age_percentile = np.percentile(age,
                               np.append(np.arange(0, 100, num_cat),
                                         100))
lf_min = min(delta_LF_mut/LF_positive)
lf_max = max(delta_LF_mut/LF_positive)
for i in range(num_cat):
    p_category = cor_GE[1][np.logical_and(age > age_percentile[i],
                                          age <= age_percentile[i+1])]
    p_category_rank = p_category.argsort().argsort()
    delta_LF_mut_category = delta_LF_mut[
        np.logical_and(age > age_percentile[i],
                       age <= age_percentile[i + 1])
    ]
    relative_LF_mut = delta_LF_mut_category/LF_positive
    # p_BH_category = p_BH[np.logical_and(age > age_percentile[i],
    #                                   age <= age_percentile[i+1])]
    num_allele = len(p_category)
    # proportion_sig.append(sum(p_category < 0.05) / num_allele)
    plt.scatter(p_category_rank, relative_LF_mut,
                marker="o",
                c="grey", alpha=0.2)
    plt.ylim(lf_min*1.10, lf_max*1.05)
    plt.xlabel("GEA p-values ranks")
    plt.ylabel("Relative $LF_{mut}$")
    plt.title("Rank bin" + str(i))
    plt.tight_layout()
    plt.savefig(figPath + model_name + "AgeBin" + str(i) +
                "_corGEpvalueRank_vs_relativeLFmut.png",
                dpi=300)
    plt.close()

# # ln(positive LF_mut) ~ ln(cor_GE p-values), colored by age
# # Remove negative LF values and 0 allele age for some plots
# positive_lfmut_age = age[delta_LF_mut > 0]
# positive_lfmut = delta_LF_mut[delta_LF_mut > 0]
# positive_lfmut_gea = cor_GE[1][delta_LF_mut > 0]
# (tau, p) = stats.kendalltau(positive_lfmut_age, positive_lfmut)
#
# plt.scatter(np.log(positive_lfmut_gea), np.log(positive_lfmut),
#          marker="o",
#          c=positive_lfmut_age, alpha=0.2)
# plt.xlabel("ln(GEA p-values)")
# plt.ylabel("ln($LF_{mut}$)")
# plt.colorbar()
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_ageColor_positveLn.png",
#             dpi=300)
# plt.close()

#### Compare to the time of demographic history ####
# Histogram of raw GEA p-values by allele age: before/after expansion
num_phase = 2
# age_timeCat = np.array([0.0, 10000, max(age)])
boundary = current_tick - history
age_timeCat = np.array([0.0, boundary, max(age)])
k = 0
proportion_sig = []
names = ["After heterogeneous selection", "Before heterogeneous selection"]
lf_min = min(delta_LF_mut/LF_positive)
lf_max = max(delta_LF_mut/LF_positive)
for i in range(num_phase):
    p_category = cor_GE[1][np.logical_and(age > age_timeCat[i],
                                      age <= age_timeCat[i+1])]
    print()
    # p_BH_category = p_BH[np.logical_and(age > age_timeCat[i],
    #                                   age <= age_timeCat[i+1])]
    p_category_rank = p_category.argsort().argsort()
    delta_LF_mut_category = delta_LF_mut[
        np.logical_and(age > age_timeCat[i],
                       age <= age_timeCat[i + 1])
    ]
    relative_LF_mut_category = delta_LF_mut_category / LF_positive

    # p-value histograms by time phases
    plt.hist(p_category,
             bins=100,
             color="grey")
    plt.xlabel("GEA p-values")
    plt.ylabel("Count")
    plt.title(names[k])
    plt.savefig(figPath+model_name+"_GEA_pvalue_hist_byAgePhases"+str(i)+".png",
                dpi=300)
    plt.close()
    # Scatter plots by time phases: LF_mut～p-value
    plt.scatter(p_category_rank, relative_LF_mut_category,
                marker="o",
                c="grey", alpha=0.2)
    plt.ylim(lf_min * 1.10, lf_max * 1.05)
    plt.xlabel("GEA p-values ranks")
    plt.ylabel("Relative $LF_{mut}$")
    plt.title(names[k])
    plt.tight_layout()
    plt.savefig(figPath + model_name + "_byAgePhases" + str(i) +
                "_corGEpvalueRank_vs_relativeLFmut.png",
                dpi=300)
    plt.close()
    k += 1


plt.scatter(abs(cor_GE[0]), delta_LF_mut,
         marker="o",
         c=np.log10(age), alpha=0.2)
plt.xlabel("|GEA Kendall's tau|")
plt.ylabel("$LF_{mut}$")
plt.colorbar().set_label("log10(allele age)")
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEcoef_vs_LF_mut_log10ageColor.png",
            dpi=300)
plt.close()

# # Check the distribution of mutation with largest LF_mut
# np.nanargmax(delta_LF_mut)
# maxlf_mut = np.reshape(freq_sample_pop[np.nanargmax(delta_LF_mut)],
#                        (10, 10))
# # Plot
# fig, ax = plt.subplots()
# im = ax.imshow(maxlf_mut)
# plt.savefig(figPath+model_name+"_maxLF_distribute.png",
#             dpi=300)
# plt.close()
#
# #Check the distribution of the mutation with most significant cor_GE
# np.nanargmin(cor_GE[1])
# minp_mut = np.reshape(freq_sample_pop[np.nanargmin(cor_GE[1])],
#                       (10, 10))
# #Plot
# fig, ax = plt.subplots()
# im = ax.imshow(minp_mut)
# plt.savefig(figPath+model_name+"_min_p_distribute.png",
#             dpi=300)
# plt.close()

# Allele frequencies
# LF_mut ~ cor_GE p-values, colored by Allele frequencies
plt.scatter(cor_GE[1], delta_LF_mut,
         marker="o",
         c=freq, alpha=0.2)
plt.xlabel("GEA p-values")
plt.ylabel("$LF_{mut}$")
plt.colorbar().set_label("Allele frequency")
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_freqColor.png",
            dpi=300)
plt.close()




# TPR ～ Allele age
plt.plot(np.arange(100/num_cat, 101, 100/num_cat),
         TPR,
         color="grey")
plt.xlabel("Allele age percentile bins")
# plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
plt.ylabel("True positive rate (TP/(TP+FN))")
plt.xticks(ticks=np.arange(100/num_cat, 101, 100/num_cat),
           labels=[(str(i*cat_width)+"-"+str((i+1)*cat_width))
                   for i in range(num_cat)])
# plt.savefig(figPath+model_name+"_proportionGEABHp_vs_age.png",
#             dpi=300)
plt.tight_layout()
plt.savefig(figPath+model_name+"_minLF"+str(LF_min)+"_"+
            str(num_cat)+"bins"+"_TPR_lfmut1percent_GEABHp0.05_vs_age.png",
            dpi=300)
plt.close()

# FPR ～ Allele age
plt.plot(np.arange(100/num_cat, 101, 100/num_cat),
         FPR,
         color="grey")
plt.xlabel("Allele age percentile bins")
# plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
plt.ylabel("False positive rate (FP/(FP+TN)))")
plt.xticks(ticks=np.arange(100/num_cat, 101, 100/num_cat),
           labels=[(str(i*cat_width)+"-"+str((i+1)*cat_width))
                   for i in range(num_cat)])
# plt.savefig(figPath+model_name+"_proportionGEABHp_vs_age.png",
#             dpi=300)
plt.tight_layout()
plt.savefig(figPath+model_name+"_minLF"+str(LF_min)+"_"+
            str(num_cat)+"bins"+"_FPR_lfmut1percent_GEABHp0.05_vs_age.png",
            dpi=300)
plt.close()


# FDR ～ Allele age
plt.plot(np.arange(100/num_cat, 101, 100/num_cat),
         FDR,
         color="grey")
plt.xlabel("Allele age percentile bins")
# plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
plt.ylabel("False discovery rate (FP/(FP+TP)))")
plt.xticks(ticks=np.arange(100/num_cat, 101, 100/num_cat),
           labels=[(str(i*cat_width)+"-"+str((i+1)*cat_width))
                   for i in range(num_cat)])
# plt.savefig(figPath+model_name+"_proportionGEABHp_vs_age.png",
#             dpi=300)
plt.tight_layout()
plt.savefig(figPath+model_name+"_minLF"+str(LF_min)+"_"+
            str(num_cat)+"bins"+"_FDR_lfmut1percent_GEABHp0.05_vs_age.png",
            dpi=300)
plt.close()

