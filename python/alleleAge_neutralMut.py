"""Explore how the performance of GEA is affected by allele ages and how this effect interact with demographic history,
using tree sequences generated by CONTINUOUS SPACE nonWF models in SLiM
Neutral mutations are added after SLiM simulations at a rate of 5e-8
(3.75e-8, Ingvarsson 2008, doi: 10.1534/genetics.108.090431.)
tianlin.duan42@gmail.com
2024.02.26
"""
############################# modules #########################################
import msprime
import tskit
import pyslim
import matplotlib.pyplot as plt
import scipy.stats as stats
from scipy.spatial import distance_matrix
import numpy as np
import random
from time import time

############################# functions #######################################
def tree_heights(treeSequences):
    kb = [0]
    mrca_t = []
    for tree in treeSequences.trees():
        kb.append(tree.interval.right / 1000)
        if tree.has_multiple_roots:
            # Use the maximum time when not coalesced
            mrca_t.append(treeSequences.metadata["SLiM"]["tick"])
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            mrca_t.append(tree.time(real_root))
    return mrca_t, kb

def tree_height(tree, max_tick):
    if tree.has_multiple_roots:
        # Use the maximum time when not coalesced
        tmrca = (max_tick)
    else:
        children = tree.children(tree.root)
        real_root = tree.root if len(children) > 1 else children[0]
        tmrca = (tree.time(real_root))
    return tmrca

def LF_fitness_loop(ind_x, ind_y, phenotype, optimal, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        optimal of the localtion of each individual(array-like),
        a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return an array of the difference of average fitness of local and foreign individuals.
    v1: memory efficient but not time efficient
    """
    w_foreign = []
    w_local = []
    for i in range(len(ind_x)):
        dist = np.sqrt((ind_x - ind_x[i]) ** 2 + (ind_y - ind_y[i]) ** 2)
        w_all = 1.0 + stats.norm.pdf(phenotype, optimal[i], sigma_w)
        w_relative = np.array(w_all / np.mean(w_all))
        w_foreign.append(np.mean(w_relative[dist > dist_mate]))
        w_local.append(np.mean(w_relative[dist <= dist_mate]))
    return np.array(w_local), np.array(w_foreign)

def LF_fitness(ind_x, ind_y, phenotype,
               optimal, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        environmental optimals (array-like), a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return two arrays of the average fitness of local and foreign individuals, respectively.
    v2: time efficient but not memory efficient.
    Try the other version when the number of individuals is large.
    """
    optimal=np.array(optimal)
    coord = list(zip(ind_x, ind_y))
    dist_matrix = distance_matrix(coord, coord)
    isLocal_matrix = dist_matrix <= dist_mate
    # Calculate fitness matrix (w_matrix[i][j]: individual j at location i) with broadcast
    w_matrix = 1.0 + stats.norm.pdf(np.array(phenotype),
                                    np.array(optimal)[:, np.newaxis],
                                    sigma_w)
    # relative fitness
    w_matrix = w_matrix / np.mean(w_matrix, 1)[:, np.newaxis]
    #Average relative fitness of local and foreign individuals
    w_local = np.mean(np.ma.masked_array(w_matrix, np.invert(isLocal_matrix)), 1)
    w_foreign = np.mean(np.ma.masked_array(w_matrix, isLocal_matrix), 1)
    return w_local, w_foreign

############################# program #########################################
#Values
sigma_w = 0.4
dist_mate = 0.1

#M2b
# model_name = "Continuous_nonWF_M2b_mu1.0e-09_sigmaM0.4_sigmaW0.4_seed4211585214153878784_tick20000"
# model_name = "Continuous_nonWF_M2b_mu1.0e-09_sigmaM0.4_sigmaW0.4_seed4211585214153878784_tick10400"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed2186716867923388027_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.1_seed2805110583194452015_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.4_seed1207239118116064755_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.01_sigmaW2.0_seed674562876216857337_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.4_seed420342970716621951_tick20000"
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW0.4_seed4094191535017385840_tick20000"

#Set 1: sigmaM0.1, sigmaW2.0
#M0a
model_name = "Continuous_nonWF_M0a_mu1.0e-09_sigmaM0.1_seed159493640993233401_tick20000"
#M0b
# model_name = "Continuous_nonWF_M0b_neutralHistory_mu1.0e-09_sigmaM0.1_seed4262922979799227249_tick20000"
#M1a
# model_name = "Continuous_nonWF_M1a_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed2043775523926582509_tick20000"
#M1b
# model_name = "Continuous_nonWF_M1b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed1704698170862545749_tick20000"
#M2a
# model_name = "Continuous_nonWF_M2a_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed432632840517966805_tick20000"
#M2b
# model_name = "Continuous_nonWF_M2b_neutralHistory_mu1.0e-09_sigmaM0.1_sigmaW2.0_seed443882937971756522_tick20000"


inPath = "/home/tianlin/Documents/github/data/slim_data/"
figPath = "/home/tianlin/Documents/github/data/tskit_data/figure/"
outPath = "/home/tianlin/Documents/github/data/tskit_data/output/"

# Tree-sequence file from SLiM
ts = tskit.load(inPath + model_name + ".trees")
ind_x, ind_y, ind_z = zip(*ts.individuals_location)
# Genomic position of sites
pos = ts.sites_position
# Genomic position of mutations
pos_by_mut = ts.sites_position[ts.mutations_site]
# Maximum tick
max_tick = ts.metadata["SLiM"]["tick"]
# Number of diploid individuals
N = ts.num_individuals
# Environmental optimal
optimal = np.array(ind_x)

# Recapitation
ts_recap = pyslim.recapitate(ts, ancestral_Ne=5e3,
                             recombination_rate=1e-7,
                             random_seed=1)

(tmrca_recap, kb_recap) = tree_heights(ts_recap)

# Add neutral mutations
mutation_seed = random.randint(1, 2**31)
mut_model1 = msprime.SLiMMutationModel(type=1)
mts = msprime.sim_mutations(ts_recap,
                            rate=5e-8,
                            random_seed=mutation_seed,
                            model=mut_model1,
                            keep=True) #keep the existing mutations

# Phenotypic effect of each mutation
# 1-dimensional
mut_effect = []
for mut in mts.mutations():
    mut_effect.append(mut.metadata['mutation_list'][0]['selection_coeff'])
mut_effect = np.array(mut_effect)

# 2-dimensional: list of lists, corresponding to phenotypic effect of allele 0/1/2... at each site
mut_effect_lists = []
for site in mts.sites():
    effect_site = [0]
    for mut in site.mutations:
        effect_site.append(mut.metadata['mutation_list'][0]['selection_coeff'])
    mut_effect_lists.append(effect_site)

# Observed extent of local adaptation (local-foreign contrast (LF))
(w_local, w_foreign) = LF_fitness(ind_x, ind_y, ind_z,
                                  optimal, dist_mate, sigma_w)
LF_cline = w_local - w_foreign
mean_LF = np.mean(LF_cline)
# Overall extent of local adaptation
#print(mean_LF)

# Display the average fitness of local and foreign populations
plt.figure(1)
plt.boxplot([w_local, w_foreign],
            labels=["Local", "Foreign"])
plt.xlabel("Groups")
plt.ylabel("Average relative fitness")
# plt.show()
plt.savefig(figPath + str(model_name) + "_test_localAdapt.png",
            dpi=300)
plt.close()

# Contribution of each mutation to LF
# Version 2: randomizing the distribution of the mutation
# Skip calculation for neutral mutations
shuffle_replicates = 1
LF_shuffle = []
t = time()
index_site = 0
# traverse sites with mutations
for v in mts.variants():
    # Skip calculation and directly append mean_LF as LF_shuffle
    # By definition neutral mutations should not affect phenotypes at all
    if sum(mut_effect_lists[index_site]) == 0:
        index_gt = 1
        while index_gt < len(mut_effect_lists[index_site]):
            LF_shuffle.append(mean_LF)
            index_gt += 1
    else:
        # Calculate the effect of each mutation at the focal site
        index_gt = 1
        # traverse all derived alleles at the site
        while index_gt < len(mut_effect_lists[index_site]):
            # for multiallelic sites, hide other alleles at the site except the focal allele,
            # leave only one allele at each time
            focal_gt = np.array(v.genotypes)
            focal_gt[focal_gt != index_gt] = 0
            # effect of the focal mutation in each individual
            effect_mut_genomes = np.array(mut_effect_lists[index_site])[focal_gt]
            # Add up the two genomes of each individual
            effect_mut_ind = (effect_mut_genomes[range(0, 2 * N - 1, 2)] +
                              effect_mut_genomes[range(1, 2 * N, 2)])
            phenotype_without_mut = ind_z - effect_mut_ind
            # Shuffle the distribution of the individuals
            # (without changing the observed heterozygosity)
            r = 0
            LF_shuffle_mut = np.zeros(shuffle_replicates)
            while r < shuffle_replicates:
                effect_mut_ind_shuffle = list(effect_mut_ind)  # shallow copy
                np.random.shuffle(effect_mut_ind_shuffle)
                # print(list(effect_mut_ind))
                # print(effect_mut_ind_shuffle)
                # Phenotype with shuffled mut =
                # phenotypes of each ind - effect of the focal mutation in each ind
                # + effect of the focal mutation in each ind after shuffling
                phenotype_shuffle = phenotype_without_mut + effect_mut_ind_shuffle
                (w_local, w_foreign) = LF_fitness(ind_x, ind_y, phenotype_shuffle,
                                                  ind_x, dist_mate, sigma_w)
                LF_shuffle_mut[r] = np.mean(w_local - w_foreign)
                r += 1
            LF_shuffle.append(np.mean(LF_shuffle_mut))
            index_gt += 1
    index_site += 1
    if index_site % 10000 == 0:
        print(f"{index_site} sites processed")
delta_LF_mut = mean_LF-LF_shuffle
# Elapsed Time
timer = time() - t
print(timer/60)
# for 1 replicate, 373377 neutral sites and 200 functional sites take 4 minutes

# Save the contribution of each mutation to LF
with open(outPath+model_name + "delta_LF_shuffle" +
          str(shuffle_replicates) + "_withNeutralMut_mutSeed" +
          str(mutation_seed) + ".txt", "w") as fout:
    for item in delta_LF_mut:
        fout.write(str(item) + "\n")
fout.close()

# Load LF from file
delta_LF_mut = np.loadtxt(outPath+model_name + "delta_LF_shuffle" +
          str(shuffle_replicates) + "_withNeutralMut_mutSeed" +
          str(mutation_seed) + ".txt")

# Age of each mutation
age = mts.mutations_time
pos_by_mut = mts.sites_position[mts.mutations_site]

# Mutation effects by mutation coordinates
effect_by_mut = np.full(shape=mts.num_mutations,
                        fill_value=np.nan)

# t0 = time()
# effect_by_mut = np.full(shape=mts.num_mutations,
#                         fill_value=np.nan)
# i = 0
# for site in mts.sites():
#     for mut in site.mutations:
#         effect_by_mut[i] = mut.metadata['mutation_list'][0]['selection_coeff']
#         i += 1
# timer = time() - t0
# print(timer) # Very slightly faster

effect_by_mut = []
for site in mts.sites():
    for mut in site.mutations:
        effect_by_mut.append(mut.metadata['mutation_list'][0]['selection_coeff'])
effect_by_mut = np.array(effect_by_mut)

# Frequency of each mutation
freq = []
num_samples = mts.num_samples
for v in mts.variants():
    for allele in np.arange(1, v.num_alleles):
        focal_freq = np.count_nonzero(v.genotypes == allele)/num_samples
        freq.append(focal_freq)

# TMRCA of all samples at the position of each mutation
# # t0 = time()
# t0 = time()
# tmrca_mut = []
# for p in pos_by_mut:
#     tmrca_mut.append(tree_height(mts.at(p), max_tick))
# timer = time() - t0
# print(timer)

tmrca_mut = np.full(shape=mts.num_mutations,
                    fill_value=np.nan)
i = 0
for p in pos_by_mut:
    tmrca_mut[i] = tree_height(mts.at(p), max_tick)
    i += 1

# Remove negative LF values and 0 allele age for some plots
age_positveLFandAge = age[np.logical_and(delta_LF_mut > 0, age > 0)]
delta_LF_mut_positveLFandAge = delta_LF_mut[np.logical_and(delta_LF_mut > 0,
                                                           age > 0)]
age_positveLFandAge_log = np.log(age_positveLFandAge)
delta_LF_mut_positveLFandAge_log = np.log(delta_LF_mut_positveLFandAge)



#### Basic plots
# Histogram of non-0 LF_mut
plt.hist(delta_LF_mut[delta_LF_mut != 0], bins=100,
         color="grey")
plt.xlabel("$LF_{mut}$")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_non0LFhist.png",
            dpi=300)
plt.close()

# Histogram of positive LF
plt.hist(delta_LF_mut[delta_LF_mut > 0], bins=100,
         color="grey")
# plt.title("With local adapation")
plt.xlabel("$LF_{mut}$")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_LFhist_positive.png",
            dpi=300)
plt.close()

# Cumulative plot of LF_mut
expected_explained_proportion = 0.8
sorted_lfmut = np.array(list(reversed(sorted(delta_LF_mut_positveLFandAge))))
positiveTotal = sum(sorted_lfmut)
cumulative_lf = [0] + [sum(sorted_lfmut[0:k+1])/positiveTotal
                       for k in range(len(sorted_lfmut))]
# How many alleles do we need to account for 80% of current local adaptation?
gea_goal = sum(np.array(cumulative_lf) < expected_explained_proportion)
explained = cumulative_lf[gea_goal]
plt.plot(range(len(sorted_lfmut)+1), cumulative_lf,
         color="lightseagreen")
plt.xlabel("Mutations sorted in descending order of $LF_{mut}$")
plt.ylabel("Cumulative proportion of positive LF")
# plt.axvline(x=gea_goal, color="firebrick", linestyle="dotted")
# plt.axhline(y=explained, color="firebrick", linestyle="dotted")
plt.plot([gea_goal+1, gea_goal+1], [0, explained],
         color="firebrick", linestyle="dotted")
plt.plot([0, gea_goal+1], [explained, explained],
         color="firebrick", linestyle="dotted")
plt.annotate(str(gea_goal), xy=(gea_goal+1, explained),
             xytext=(gea_goal + 1 + len(cumulative_lf)/40, 0),
             color="firebrick")
plt.savefig(figPath + model_name + "_LFcumulative_positive.png",
            dpi=300)
plt.close()

# # LF ~ phenotypic effect size
# plt.plot(abs(mut_effect), delta_LF_mut,
#          marker="o", linestyle="",
#          color="saddlebrown", alpha=0.1)
# plt.xlabel("|Phenptypic effect size|")
# # plt.ylabel("$LF_{mutation}$ (ln)")
# plt.ylabel("$LF_{mutation}$")
# # plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
# #             dpi=100)
# plt.savefig(figPath+model_name+"continuousWF_phenoEffectAndLF.png",
#             dpi=300)
# plt.close()

# LF ~ |phenotypic effect size|
plt.scatter(abs(mut_effect), delta_LF_mut,
            marker="o",
            c=age, alpha=0.2)
plt.xlabel("|Phenotypic effect size|")
plt.ylabel("$LF_{mut}$")
plt.colorbar()
plt.tight_layout()
plt.savefig(figPath+model_name+"_phenoEffectAndLF_ageColor.png",
            dpi=300)
plt.close()

# # positive LF ~ allele age
# tempx = age_positveLFandAge_log
# tempy = delta_LF_mut_positveLFandAge_log
# res = stats.linregress(tempx, tempy)
# rsquared = round(res.rvalue ** 2, 3)
# linearp = '{:0.2e}'.format(res.pvalue)
# spr = stats.spearmanr(age, delta_LF_mut)
# spr_positive = stats.spearmanr(age_positveLFandAge, tempy)
#
# plt.figure(1)
# plt.plot(tempx, tempy,
#          marker="o", linestyle="",
#          color="saddlebrown", alpha=0.1)
# plt.plot(sorted(tempx),
#          res.intercept + np.array(sorted(tempx))*res.slope,
#          color = "cornflowerblue")
# plt.text(0, min(tempy)+(max(tempy)-min(tempy))*0.9,
#          "$r^{2}$="+str(rsquared)+"\n" + "p-value=" + str(linearp),
#          color = "cornflowerblue")
# # plt.axline((0,res.intercept),
# #            slope=res.slope, color="cornflowerblue",
# #            label = "")
# # plt.title("With local adapation")
# plt.xlabel("ln(Mutation age)")
# plt.ylabel("ln(Positive $LF_{mut})$")
# plt.savefig(figPath+model_name+"_ageAndLF_ln.png",
#             dpi=300)
# plt.close()

# non-0 |LF| ~ allele age
tempx = np.log(age[np.logical_and(delta_LF_mut != 0, age != 0)])
tempy = np.log(np.abs(delta_LF_mut[np.logical_and(delta_LF_mut != 0, age != 0)]))
res = stats.linregress(tempx, tempy)
rsquared = round(res.rvalue ** 2, 3)
slope = '{:0.2e}'.format(res.slope)
linearp = '{:0.2e}'.format(res.pvalue)
spr_abs = stats.spearmanr(tempx, tempy)
plt.figure(1)
plt.plot(tempx, tempy,
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.1)
plt.plot(sorted(tempx),
         res.intercept + np.array(sorted(tempx))*res.slope,
         color = "cornflowerblue")
plt.text(0, min(tempy)+(max(tempy)-min(tempy))*0.9,
         "$r^{2}$="+str(rsquared) + "\n" +
         "P-value=" + str(linearp) + "\n" +
         "Slope=" + str(slope),
         color = "cornflowerblue")
# plt.axline((0,res.intercept),
#            slope=res.slope, color="cornflowerblue",
#            label = "")
# plt.title("With local adapation")
plt.xlabel("ln(Mutation age)")
plt.ylabel("ln(|$LF_{mut})$|")
plt.savefig(figPath+model_name+"_non0ageAndAbsoluteNon0LF_ln.png",
            dpi=300)
plt.close()


#### cor Freq-Env as a proximation of GEA
# Divide the population into 10x10 sample-populations, for each sample population,
# calculate the correlation between allele frequency of each mutation
# and average local environmental variable(optimal)
# Assign a two-digit sample-pop id for each individual
# |90|91|92|93|94|95|96|97|98|99|
# ...
# |20|21|22|23|24|25|26|27|28|29|
# |10|11|12|03|14|15|16|17|18|19|
# |00|01|02|03|04|05|06|07|08|09|
map_width = 1.0
map_height = 1.0
# Only works when both num_row and num_col <= 10
num_row = 10
num_col = 10
num_sample_pop = num_row * num_col
sample_pop_ids = np.zeros(mts.num_individuals)
sample_pop_ids[:] = np.nan
i = 0
for ind in mts.individuals():
    x = int(ind.location[0]/(map_width/num_row))
    y = int(ind.location[1]/(map_width/num_col))
    # Push the ones on the upper boundaries back
    x = x if x < num_row else (num_row-1)
    y = y if y < num_col else (num_col-1)
    sample_pop_ids[i] = (x+y*10)
    i += 1
# # Check the sample size of the grids
# plt.hist(sample_pop_ids, bins=100,
#          color="grey")
# plt.savefig(figPath+model_name+"_subsample_size.png",
#             dpi=300)
# plt.close()

# A collection of individual IDs for each sample population
inds_sample_pop = {}
# Average environmental optimal of each sample population,
# calculated by the position of all local individuals
env_sample_pop = np.zeros(num_sample_pop)
env_sample_pop[:] = np.nan
# A vector of allele frequencies of all mutations for each sample population
freq_sample_pop = np.zeros(shape=(mts.num_mutations, num_sample_pop))
freq_sample_pop[:] = np.nan
for focal_pop_id in np.arange(num_sample_pop):
    focal_ind_list = np.array(np.where(sample_pop_ids == focal_pop_id)[0])
    focal_genome_list = np.stack((focal_ind_list*2,focal_ind_list*2+1)).ravel('F')
    inds_sample_pop[focal_pop_id] = focal_ind_list
    # Current map: local env optimals = x coordinates of local samples
    env_sample_pop[focal_pop_id] = np.mean(mts.individuals_location[focal_ind_list][:, 0])
    # Calculate derived allele frequency of all mutations in focal population
    index_site = 0
    index_mut = 0
    for v in mts.variants(samples=focal_genome_list):
        # Will cause an ERROR for multi-allelic sites
        index_gt = 1
        # traverse all derived alleles at the site
        while index_gt < len(mut_effect_lists[index_site]):
            # print(type(v.genotypes))
            derived_freq = np.count_nonzero(v.genotypes==index_gt)/len(focal_genome_list)
            # print(len(focal_ind_list))

            # print(v.frequencies())
            # print(derived_freq)
            freq_sample_pop[index_mut][focal_pop_id] = derived_freq
            index_gt += 1
            index_mut += 1
        index_site += 1

# Correlation between allele frequency and environmental optima
# correlation coefficient and p-value
cor_GE = np.zeros(shape=(2, mts.num_mutations))
cor_GE[:] = np.nan
for i in np.arange(mts.num_mutations):
    # fixed/lost mutations would raise a statistic error
    if sum(freq_sample_pop[i]) > 0:
        # position 0: correlation coefficients, position 1: p-values
        # (cor_GE[0][i], cor_GE[1][i]) = stats.spearmanr(freq_sample_pop[i],
        #                                                env_sample_pop)
        (cor_GE[0][i], cor_GE[1][i]) = stats.kendalltau(freq_sample_pop[i],
                                                        env_sample_pop)


# Histogram of GEA p-values
plt.hist(cor_GE[1], bins=100,
         color="grey")
plt.xlabel("GEA p-values")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_GEA_pvalue_hist.png",
            dpi=300)
plt.close()

# Histogram of allele age
plt.hist(age, bins=100,
         color="grey")
plt.xlabel("Allele age")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_age_hist.png",
            dpi=300)
plt.close()

# Histogram of GEA p-values by allele age
num_cat = 10
age_percentile = np.percentile(age, np.append(np.arange(0, 100, num_cat),100))
k = 0
for i in range(num_cat):
    k += len(cor_GE[1][np.logical_and(age > age_percentile[i],
                                      age < age_percentile[i+1])])
    plt.hist(cor_GE[1][np.logical_and(age > age_percentile[i],
                                      age < age_percentile[i+1])],
             bins=100,
             color="grey")
    plt.xlabel("GEA p-values")
    plt.ylabel("Count")
    plt.savefig(figPath+model_name+"_GEA_pvalue_hist_byAge_bin"+str(i)+".png",
                dpi=300)
    plt.close()
print(k)

# Histogram of GEA tau
plt.hist(cor_GE[0], bins=100,
         color="grey")
plt.xlabel("GEA Kendall's tau")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_GEA_tau_hist.png",
            dpi=300)
plt.close()




# LF_mut ~ cor_GE p-values, colored by age
plt.scatter(cor_GE[1], delta_LF_mut,
         marker="o",
         c=age, alpha=0.2)
plt.xlabel("GEA p-values")
plt.ylabel("$LF_{mut}$")
plt.colorbar()
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_ageColor.png",
            dpi=300)
plt.close()

# ln(positive LF_mut) ~ ln(cor_GE p-values), colored by age
# Remove negative LF values and 0 allele age for some plots
positive_lfmut_age = age[delta_LF_mut > 0]
positive_lfmut = delta_LF_mut[delta_LF_mut > 0]
positive_lfmut_gea = cor_GE[1][delta_LF_mut > 0]
(tau, p) = stats.kendalltau(positive_lfmut_age, positive_lfmut)

plt.scatter(np.log(positive_lfmut_gea), np.log(positive_lfmut),
         marker="o",
         c=positive_lfmut_age, alpha=0.2)
plt.xlabel("ln(GEA p-values)")
plt.ylabel("ln($LF_{mut}$)")
plt.colorbar()
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_ageColor_positveLn.png",
            dpi=300)
plt.close()

plt.scatter(abs(cor_GE[0]), delta_LF_mut,
         marker="o",
         c=age, alpha=0.2)
plt.xlabel("|GEA Kendall's tau|")
plt.ylabel("$LF_{mut}$")
plt.colorbar()
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEcoef_vs_LF_mut_ageColor.png",
            dpi=300)
plt.close()

# # Check the distribution of mutation with largest LF_mut
# np.nanargmax(delta_LF_mut)
# maxlf_mut = np.reshape(freq_sample_pop[np.nanargmax(delta_LF_mut)],
#                        (10, 10))
# # Plot
# fig, ax = plt.subplots()
# im = ax.imshow(maxlf_mut)
# plt.savefig(figPath+model_name+"_maxLF_distribute.png",
#             dpi=300)
# plt.close()
#
# #Check the distribution of the mutation with most significant cor_GE
# np.nanargmin(cor_GE[1])
# minp_mut = np.reshape(freq_sample_pop[np.nanargmin(cor_GE[1])],
#                       (10, 10))
# #Plot
# fig, ax = plt.subplots()
# im = ax.imshow(minp_mut)
# plt.savefig(figPath+model_name+"_min_p_distribute.png",
#             dpi=300)
# plt.close()

# Allele frequencies
# LF_mut ~ cor_GE p-values, colored by Allele frequencies
plt.scatter(cor_GE[1], delta_LF_mut,
         marker="o",
         c=freq, alpha=0.2)
plt.xlabel("GEA p-values")
plt.ylabel("$LF_{mut}$")
plt.colorbar()
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_freqColor.png",
            dpi=300)
plt.close()



