"""
Explore how the performance of GEA is affected by allele ages and how this
effect interact with demographic history,
using tree sequences generated by CONTINUOUS SPACE nonWF models in SLiM
Updates compared to alleleAge.py:
    Neutral mutations are added after SLiM simulations at a rate of 5e-8
    (3.75e-8, Ingvarsson 2008, doi: 10.1534/genetics.108.090431.)
tianlin.duan42@gmail.com
2024.03.22
"""
############################# modules #########################################
import msprime
import tskit
# import pyslim # for recapitation
import matplotlib.pyplot as plt
import scipy.stats as stats
from scipy.spatial import distance_matrix
import numpy as np
# import pandas
import random
import time
import sys # for sys.exit()
import allel # for allel.weir_cockerham_fst()
import os # mkdir
# import tracemalloc check memory usage

############################# options #############################
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('-i', '--input',
                    help='Input .trees file with its absolute path',
                    type=str)
parser.add_argument('-p', '--plot',
                    help='1 for generating plots and 0 for not plotting',
                    type=int, default=1)
args = parser.parse_args()

############################# functions #######################################
def tree_heights(tree_sequences):
    kb = [0]
    mrca_t = []
    for tree in tree_sequences.trees():
        kb.append(tree.interval.right / 1000)
        if tree.has_multiple_roots:
            # Use the maximum time when not coalesced
            mrca_t.append(tree_sequences.metadata["SLiM"]["tick"])
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            mrca_t.append(tree.time(real_root))
    return mrca_t, kb

def tree_height(tree, maximum_tick):
    if tree.has_multiple_roots:
        # Use the maximum time when not coalesced
        tmrca = maximum_tick
    else:
        children = tree.children(tree.root)
        real_root = tree.root if len(children) > 1 else children[0]
        tmrca = (tree.time(real_root))
    return tmrca

# def lf_fitness_loop(ind_x, ind_y, phenotype, optima, dist_mate, sigma_w):
#     """Takes x and y coordinates (array-like), phenotypes (array-like),
#         optima of the localtion of each individual(array-like),
#         a maximum distance for mating (single value),
#         and a standard deviation of fitness function (single value).
#     Return an array of the difference of average fitness of local and foreign individuals.
#     v1: memory efficient but not time efficient
#     """
#     w_foreign = []
#     w_local = []
#     for i in range(len(ind_x)):
#         dist = np.sqrt((ind_x - ind_x[i]) ** 2 + (ind_y - ind_y[i]) ** 2)
#         w_all = 1.0 + stats.norm.pdf(phenotype, optima[i], sigma_w)
#         w_relative = np.array(w_all / np.mean(w_all))
#         w_foreign.append(np.mean(w_relative[dist > dist_mate]))
#         w_local.append(np.mean(w_relative[dist <= dist_mate]))
#     return np.array(w_local), np.array(w_foreign)

def lf_fitness(ind_x, ind_y, phenotype,
               optima, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        environmental optima (array-like), a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return two arrays of the average fitness of local and foreign individuals, respectively.
    v2: time efficient but not memory efficient.
    Try the other version when the number of individuals is large.
    """
    optima=np.array(optima)
    coord = list(zip(ind_x, ind_y))
    dist_matrix = distance_matrix(coord, coord)
    isLocal_matrix = dist_matrix <= dist_mate
    # Calculate fitness matrix (w_matrix[i][j]: individual j at location i) with broadcast
    w_matrix = 1.0 + stats.norm.pdf(np.array(phenotype),
                                    np.array(optima)[:, np.newaxis],
                                    sigma_w)
    # relative fitness
    w_matrix = w_matrix / np.mean(w_matrix, 1)[:, np.newaxis]
    #Average relative fitness of local and foreign individuals
    w_local = np.mean(np.ma.masked_array(w_matrix, np.invert(isLocal_matrix)), 1)
    w_foreign = np.mean(np.ma.masked_array(w_matrix, isLocal_matrix), 1)
    return w_local, w_foreign

############################# program #########################################
# Values
sigma_w = 0.4
dist_mate = 0.15
history = 100000 # number of generations before the focal model

#User input arguments:
path_file_name = args.input
# path_file_name = "/home/tianlin/Documents/github/data/slim_data/glacial_history/realistic_fpr_comparisons/M2b_smallLowVm_lowMig_clineMap/Continuous_nonWF_M2b_glacialHistoryOptimum0_clineMap_mu1.0e-08_sigmaM0.01_sigmaW0.4_sigmaD0.03_mateD0.12_K17000_r1.0e-07_seed55381568486983757_tick110000.trees"
# Test with a smaller file
# path_file_name = "/home/tianlin/Documents/github/data/slim_data/glacial_history/historical_optimum0_timeSeries_gradualChange/M2b_smallLowVm_highMig_clineMap/Continuous_nonWF_M2b_glacialHistoryOptimum0_clineMap_mu1.0e-08_sigmaM0.01_sigmaW0.4_sigmaD0.06_mateD0.15_K17000_r1.0e-07_seed142788750963570601_tick100400.trees"
# path_file_name = "/home/anadem/github/data/slim_data/glacial_history/M2a_largeLowVm_lowMig_clineMap/tick110000/batch1/Continuous_nonWF_M2a_glacialHistoryOptimum0_clineMap_mu1.0e-10_sigmaM0.1_sigmaW0.4_sigmaD0.03_mateD0.12_K17000_r1.0e-07_seed700481771470451972_tick110000.trees"
# path_file_name = "/home/anadem/github/data/slim_data/glacial_history/M3a_smallLowVm_lowMig_patchyMap/timeSeries/batch1/Continuous_nonWF_M3a_glacialHistoryOptimum0_patchyMap_mu1.0e-08_sigmaM0.01_sigmaW0.4_sigmaD0.03_mateD0.12_K17000_r1.0e-07_seed170434520545088555_tick100200.trees"

# Remove paths
file_name = path_file_name.split("/")[-1]
model_name = file_name[0:-6]  # Assuming the file name extension is .trees
# Delete seed and tick information for making a directory
short_model_name = "_".join(file_name.split("_")[0:-2])

# figPath = "/home/tianlin/Documents/github/data/tskit_data/figure/20241201/"
# figPath = "/home/tianlin/ubc/data/tskit_data/figure/20241201/"
# figPath = "/home/anadem/github/data/tskit_data/figure/20241201/"
# figPath = "/home/anadem/github/data/tskit_data/figure/20250131m3ab/"
figPath = "/home/anadem/github/data/tskit_data/figure/test/"
#Figure path for the current run
figPath = figPath + model_name + "/"
if not os.path.exists(figPath):
    os.makedirs(figPath)

# outBasePath = "/home/tianlin/Documents/github/data/tskit_data/output/table/realistic_fpr_comparisons/"
# outBasePath = "/home/tianlin/ubc/data/tskit_data/output/table/realistic_fpr_comparisons/"
outBasePath = "/home/anadem/github/data/tskit_data/output/table/realistic_fpr_comparisons/"
outPath = outBasePath+short_model_name+"/"
if not os.path.exists(outPath):
    os.makedirs(outPath)


# Tree-sequence file from SLiM
ts = tskit.load(path_file_name)
current_tick = ts.metadata['SLiM']['tick']
ind_x, ind_y, ind_z = zip(*ts.individuals_location)
# Genomic position of sites
pos = ts.sites_position
# Genomic position of mutations
pos_by_mut = ts.sites_position[ts.mutations_site]
# Maximum tick
max_tick = ts.metadata["SLiM"]["tick"]
# Number of diploid individuals
N = ts.num_individuals
# Environmental optima
optima = np.array(ts.metadata['SLiM']['user_metadata']['indsOptimum'])
mapValues = np.array(ts.metadata['SLiM']['user_metadata']['mapValues'])

# Recapitation: skipped as no functional mutation was added during this stage
# ts_recap = pyslim.recapitate(ts, ancestral_Ne=5e3,
#                              recombination_rate=1e-7,
#                              random_seed=1)
#
# (tmrca_recap, kb_recap) = tree_heights(ts_recap)
# ts_recap = ts

# Add neutral mutations
mutation_seed = random.randint(1, 2**31)
mut_model1 = msprime.SLiMMutationModel(type=1)
mts = msprime.sim_mutations(ts,
                            rate=5e-8,
                            random_seed=mutation_seed,
                            model=mut_model1,
                            keep=True) #keep the existing mutations
del ts

# Phenotypic effect of each mutation
# 1-dimensional
mut_effect = []
for mut in mts.mutations():
    mut_effect.append(mut.metadata['mutation_list'][0]['selection_coeff'])
mut_effect = np.array(mut_effect)

# 2-dimensional: list of lists, corresponding to phenotypic effect of allele 0/1/2... at each site
mut_effect_lists = []
for site in mts.sites():
    effect_site = [0]
    for mut in site.mutations:
        effect_site.append(mut.metadata['mutation_list'][0]['selection_coeff'])
    mut_effect_lists.append(effect_site)

# Observed extent of local adaptation (local-foreign contrast (LF))
(w_local, w_foreign) = lf_fitness(ind_x, ind_y, ind_z,
                                  optima, dist_mate, sigma_w)
LF_cline = w_local - w_foreign
mean_LF = np.mean(LF_cline)
# Overall extent of local adaptation
#print(mean_LF)


# Contribution of each mutation to LF
# Version 2: randomizing the distribution of the mutation
# Skip calculation for neutral mutations
print("LF_mut calculation")
print(time.ctime())
shuffle_replicates = 1
LF_shuffle = []
t1 = time.time()
index_site = 0
# traverse sites with mutations
for v in mts.variants():
    # Neutral site: Skip the calculation and directly append mean_LF as LF_shuffle
    # By definition neutral mutations should not affect phenotypes at all
    if sum(mut_effect_lists[index_site]) == 0:
        index_gt = 1
        while index_gt < len(mut_effect_lists[index_site]):
            LF_shuffle.append(mean_LF)
            index_gt += 1
    else:
        # Calculate the effect of each mutation at the focal site
        index_gt = 1
        # traverse all derived alleles at the site
        while index_gt < len(mut_effect_lists[index_site]):
            # for multiallelic sites, hide all other alleles at the site,
            # but only evaluate one allele at each time
            focal_gt = np.array(v.genotypes)
            focal_gt[focal_gt != index_gt] = 0
            # effect of the focal mutation in each individual
            effect_mut_genomes = np.array(mut_effect_lists[index_site])[focal_gt]
            # Add up the two genomes of each individual
            effect_mut_ind = (effect_mut_genomes[range(0, 2 * N - 1, 2)] +
                              effect_mut_genomes[range(1, 2 * N, 2)])
            phenotype_without_mut = ind_z - effect_mut_ind
            # Shuffle the distribution of the individuals
            # (without changing the observed heterozygosity)
            r = 0
            LF_shuffle_mut = np.zeros(shuffle_replicates)
            while r < shuffle_replicates:
                effect_mut_ind_shuffle = list(effect_mut_ind)  # shallow copy
                np.random.shuffle(effect_mut_ind_shuffle)
                # Phenotype with shuffled mut =
                # phenotypes of each ind - effect of the focal mutation in each ind
                # + effect of the focal mutation in each ind after shuffling
                phenotype_shuffle = phenotype_without_mut + effect_mut_ind_shuffle
                (w_local, w_foreign) = lf_fitness(ind_x, ind_y, phenotype_shuffle,
                                                  optima, dist_mate, sigma_w)
                LF_shuffle_mut[r] = np.mean(w_local - w_foreign)
                r += 1
            LF_shuffle.append(np.mean(LF_shuffle_mut))
            index_gt += 1
    index_site += 1
    if index_site % 10000 == 0:
        print(f"{index_site} sites processed")
delta_LF_mut = mean_LF-LF_shuffle
# Elapsed Time
timer = time.time() - t1
print(str(round((timer/60),2) )+ " minutes used for LF_mut calculation.")
print(time.ctime())
# 49 min for a typical M2b run with around 350000 sites

# # Save the contribution of each mutation to LF
# with open(outPath+model_name + "delta_LF_shuffle" +
#           str(shuffle_replicates) + "_withNeutralMut_mutSeed" +
#           str(mutation_seed) + ".txt", "w") as fout:
#     for item in delta_LF_mut:
#         fout.write(str(item) + "\n")
# fout.close()
#
# # Load LF from file
# delta_LF_mut = np.loadtxt(outPath+model_name + "delta_LF_shuffle" +
#           str(shuffle_replicates) + "_withNeutralMut_mutSeed" +
#           str(mutation_seed) + ".txt")

# Age of each mutation
age = mts.mutations_time
pos_by_mut = mts.sites_position[mts.mutations_site]

# Mutation effects by mutation coordinates
effect_by_mut = []
for site in mts.sites():
    for mut in site.mutations:
        effect_by_mut.append(mut.metadata['mutation_list'][0]['selection_coeff'])
effect_by_mut = np.array(effect_by_mut)

# Frequency of each mutation
freq = []
num_samples = mts.num_samples
for v in mts.variants():
    for allele in np.arange(1, v.num_alleles):
        focal_freq = np.count_nonzero(v.genotypes == allele)/num_samples
        freq.append(focal_freq)

#Age of individuals
ind_age = []
for ind in mts.individuals():
    ind_age.append(ind.metadata['age'])

# # TMRCA of all samples at the position of each mutation
# tmrca_mut = []
# for p in pos_by_mut:
#     tmrca_mut.append(tree_height(mts.at(p), max_tick))
#
# tmrca_mut = np.full(shape=mts.num_mutations,
#                     fill_value=np.nan)
# i = 0
# for p in pos_by_mut:
#     tmrca_mut[i] = tree_height(mts.at(p), max_tick)
#     i += 1

# Remove negative LF values and 0 allele age for some plots
age_positveLFandAge = age[np.logical_and(delta_LF_mut > 0, age > 0)]
delta_LF_mut_positveLFandAge = delta_LF_mut[np.logical_and(delta_LF_mut > 0,
                                                           age > 0)]
age_positveLFandAge_log = np.log(age_positveLFandAge)
delta_LF_mut_positveLFandAge_log = np.log(delta_LF_mut_positveLFandAge)

#### cor Freq-Env as a proximation of GEA
print("Starting correlation tests")
print(time.ctime())
# Divide the population into 10x10 subpopulations, for each subpopulation,
# calculate the correlation between allele frequency of each mutation
# and average local environmental variable(optima)
# Assign a two-digit subpop id for each individual
# |90|91|92|93|94|95|96|97|98|99|
# ...
# |20|21|22|23|24|25|26|27|28|29|
# |10|11|12|03|14|15|16|17|18|19|
# |00|01|02|03|04|05|06|07|08|09|
map_width = 1.0
map_height = 1.0
# Only works when both num_row and num_col <= 10
num_row = 10
num_col = 10
num_sample_pop = num_row * num_col
sample_pop_ids = np.full(fill_value=np.nan,
                         shape=mts.num_individuals)
i = 0
for ind in mts.individuals():
    x = int(ind.location[0]/(map_width/num_row))
    y = int(ind.location[1]/(map_width/num_col))
    # Push the ones on the upper boundaries back
    x = x if x < num_row else (num_row-1)
    y = y if y < num_col else (num_col-1)
    sample_pop_ids[i] = x+y*10
    i += 1

np.unique(sample_pop_ids, return_counts=True)
# # Check the sample size of the grids
# plt.hist(sample_pop_ids, bins=100,
#          color="grey")
# plt.savefig(figPath+model_name+"_subsample_size.png",
#             dpi=300)
# plt.close()

# A collection of individual IDs for each subpopulation
inds_subpop = {}
# A collection of genome IDs for each subpopulation
genome_subpop = {}
# Average environmental optima of each sample population,
# calculated by the position of all local individuals
env_sample_pop = np.full(fill_value=np.nan,
                         shape=num_sample_pop)
# A vector of allele frequencies of all mutations for each sample population
freq_sample_pop = np.full(fill_value=np.nan,
                          shape=(mts.num_mutations, num_sample_pop))
for focal_pop_id in np.arange(num_sample_pop):
    focal_ind_list = np.array(np.where(sample_pop_ids == focal_pop_id)[0])
    focal_genome_list = np.stack((focal_ind_list*2,
                                  focal_ind_list*2+1)).ravel('F')
    inds_subpop[focal_pop_id] = focal_ind_list
    genome_subpop[focal_pop_id] = focal_genome_list
    # A special map: local env optima = x coordinates of local samples
    # env_sample_pop[focal_pop_id] = np.mean(mts.individuals_location[focal_ind_list][:, 0])
    #General form of optima
    env_sample_pop[focal_pop_id] = np.mean(optima[focal_ind_list])
    # Calculate derived allele frequency of each mutation in focal population
    index_site = 0
    index_mut = 0
    for v in mts.variants(samples=focal_genome_list):
        index_gt = 1
        # traverse all derived alleles at the site
        while index_gt < len(mut_effect_lists[index_site]):
            # if index_mut == 10000:
            #     test2 = v
            # print(v.genotypes)
            derived_freq = (np.count_nonzero(v.genotypes==index_gt) / len(focal_genome_list))
            # print(len(focal_ind_list))
            # print(v.frequencies())
            # print(derived_freq)
            freq_sample_pop[index_mut][focal_pop_id] = derived_freq
            index_gt += 1
            index_mut += 1
        index_site += 1

# Correlation between allele frequency and environmental optima
# correlation coefficient and p-value
cor_GE = np.full(fill_value=np.nan,
                 shape=(2, mts.num_mutations))
for i in np.arange(mts.num_mutations):
    # skipped fixed/lost mutations
    if sum(freq_sample_pop[i]) > 0:
        # position 0: correlation coefficients, position 1: p-values
        # (cor_GE[0][i], cor_GE[1][i]) = stats.spearmanr(freq_sample_pop[i],
        #                                                env_sample_pop)
        (cor_GE[0][i], cor_GE[1][i]) = stats.kendalltau(freq_sample_pop[i],
                                                        env_sample_pop)
print("Correlation tests finished")
print(time.ctime())

# #### Save the data table:
# # Method 1, np table
# # mutation ID, allele age, allele frequency, mutation effect, LF_mut,
# # GEA Kendall's tau and corresponding p-value
# myTable = np.array([np.arange(mts.num_mutations),
#                     age,
#                     freq,
#                     mut_effect,
#                     delta_LF_mut,
#                     cor_GE[0],
#                     cor_GE[1]])
# np.savetxt(outPath + model_name + "_fst" + str(round(fst,4)) +
#            "_withNeutralMut_mutSeed" +
#            str(mutation_seed) + "_table.txt",
#            myTable,
#            header="ID, allele_age, allele_freq, effect_size, lf_mut, tau, p")

# Method 2, loops
# mutation ID, allele age, allele frequency, mutation effect, LF_mut,
# GEA Kendall's tau and corresponding p-value
if not os.path.exists(outPath):
    os.makedirs(outPath)
print("Saving the table...")
print(time.ctime())
out_path_file = (outPath + model_name +
                 "_withNeutralMut_mutSeed" + str(mutation_seed) +
                 "_table.txt")
header = "\t".join(["pos", "age", "freq",
                    "mut_effect","delta_LF_mut",
                    "tau","p"]) + "\n"
with open(out_path_file, "w") as fout:
    fout.write(header)
    for i in range(len(age)):
        words = [pos_by_mut[i],
                        age[i],
                        freq[i],
                        mut_effect[i],
                        delta_LF_mut[i],
                        cor_GE[0][i],
                        cor_GE[1][i]]
        words = [str(i) for i in words]
        outLine = "\t".join(words) + "\n"
        fout.write(outLine)
print("The table has been saved.")
print(time.ctime())

# Skip the following lines and end the program if "--plot" is 0
if not bool(args.plot):
    print("Program finished. No plot will be generated as --plot is 0.")
    sys.exit(0)

if not os.path.exists(figPath):
    os.makedirs(figPath)

# # p-value adjusted by the Benjamini-Hochberg method
# # temporarily remove nan values
# p_mask = np.isnan(cor_GE[1])
# p_no_nan = cor_GE[1][~p_mask]
# p_BH_no_nan = stats.false_discovery_control(p_no_nan)
# p_BH = np.full(shape=len(cor_GE[1]), fill_value=np.nan)
# p_BH[~p_mask] = p_BH_no_nan

# # True positive rate, False negative rate, False discovery rate for all mutations
# # Skipped for single runs
# # True adaptive allele: account for more than LF_min percent of positve LF_mut
# # GEA significant: BH-adjusted p-value < 0.05
# LF_positive = sum(delta_LF_mut[delta_LF_mut>0])
# LF_min = 0.01
# num_cat = 10
# cat_width = int(100/num_cat) if 100 % num_cat == 0 else 100/num_cat
# age_percentile = np.percentile(age,
#                                np.append(np.arange(0, 100, cat_width),100))
# TPR = []
# FPR = []
# FDR = []
# for i in range(num_cat):
#     # p_category = cor_GE[1][np.logical_and(age > age_percentile[i],
#     #                                   age <= age_percentile[i+1])]
#     p_BH_category = p_BH[np.logical_and(age > age_percentile[i],
#                                       age <= age_percentile[i+1])]
#     delta_LF_mut_category = delta_LF_mut[np.logical_and(age > age_percentile[i],
#                                       age <= age_percentile[i+1])]
#     # num_allele = len(p_BH_category)
#     # proportion_sig.append(sum(p_BH_category < 0.05)/num_allele)
#     expP = delta_LF_mut_category > LF_min*LF_positive
#     obsP = p_BH_category < 0.05
#     TP = sum(expP & obsP)
#     FP = sum(~expP & obsP)
#     FN = sum(expP & ~obsP)
#     TN = sum(~expP & ~obsP)
#     TPR.append(TP/(TP+FN))
#     FPR.append(FP/(TN+FP))
#     FDR.append(FP/(TP+FP))


# #### Separate neutral alleles
# # mutation ID, allele age, allele frequency, mutation effect, LF_mut,
# # GEA Kendall's tau and corresponding p-value
# df = np.array([age,
#                freq,
#                mut_effect,
#                cor_GE[0],
#                cor_GE[1]])
# df_neutral = pandas.DataFrame(data=df.transpose(),
#                               columns=["age", "freq", "effect_size",
#                                        "tau", "p"])
# del df
# # Separate neutral alleles and remove lost or fixed alleles
# df_neutral = df_neutral[(df_neutral["effect_size"] == 0) &
#                         (df_neutral["freq"] != 0) &
#                         (df_neutral["freq"] != 1)]
# num_neutral_muts = df_neutral.shape[0]
#
#
# # False negative rate for NEUTRAL mutations among AGE categories
# # Equal numbers
# num_cat = 10
# cat_width = int(100/num_cat) if 100 % num_cat == 0 else 100/num_cat
# age_percentile = np.percentile(df_neutral["age"],
#                                np.append(np.arange(0, 100, cat_width),
#                                          100))
# FPR_neutral_byAge = []
# for i in range(num_cat):
#     p_category = df_neutral["p"][(df_neutral["age"] > age_percentile[i]) &
#                                  (df_neutral["age"] <= age_percentile[i+1])]
#     # Neutral mutations have no phenotypic effect and therefore no positive
#     mut_in_cat = len(p_category)
#     obsP_neutral = p_category < 0.05
#     # All positives are false positives
#     FP = sum(obsP_neutral)
#     FPR_neutral_byAge.append(FP/mut_in_cat)
#
# # False negative rate for NEUTRAL mutations among AGE categories
# # Equal width
# num_cat_age = 10
# max_age = mts.metadata['SLiM']['tick']
# cat_width_age = max_age/num_cat_age
# age_boundaries = np.append(np.arange(0, max_age, cat_width_age), max_age)
# FPR_neutral_byAge_equalWidth = []
# sample_size_age = []
# for i in range(num_cat_age):
#     p_category = df_neutral["p"][(df_neutral["age"] > age_boundaries[i]) &
#                                  (df_neutral["age"] <= age_boundaries[i+1])]
#     sample_size_age.append(len(p_category))
#     # Neutral mutations have no phenotypic effect and therefore no positive
#     mut_in_cat = len(p_category)
#     obsP_neutral = p_category < 0.05
#     # All positives are false positives
#     FP = sum(obsP_neutral)
#     FPR_neutral_byAge_equalWidth.append(FP/mut_in_cat)
#
# # False negative rate for NEUTRAL mutations among FREQUENCY categories
# # Equal numbers
# # Neutral mutations have no phenotypic effect and therefore no positve
# num_cat = 10
# cat_width = int(100/num_cat) if 100 % num_cat == 0 else 100/num_cat
# freq_percentile = np.percentile(df_neutral["freq"],
#                                np.append(np.arange(0, 100, cat_width),100))
# FPR_neutral_byFreq = []
# for i in range(num_cat):
#     if freq_percentile[i] != freq_percentile[i+1]:
#         p_category = df_neutral["p"][(df_neutral["freq"] > freq_percentile[i]) &
#                                      (df_neutral["freq"] <= freq_percentile[i+1])]
#     else:
#         # The frequency of singletons exceed bin width: Use the all singletons
#         p_category = df_neutral["p"][df_neutral["age"] == age_percentile[i]]
#     # Neutral mutations have no phenotypic effect and therefore no positive
#     mut_in_cat = len(p_category)
#     obsP_neutral = p_category < 0.05
#     # All positives are false positives
#     FP = sum(obsP_neutral)
#     FPR_neutral_byFreq.append(FP/mut_in_cat)

# # False negative rate for NEUTRAL mutations among FREQ categories
# # Equal intervals
# num_cat_freq = 10
# cat_width_freq = 1.0/num_cat_freq
# freq_boundaries = np.append(np.arange(0, 1.0, cat_width_freq), 1.0)
# FPR_neutral_byFreq_equalWidth = []
# sample_size_freq = []
# for i in range(num_cat_freq):
#     p_category = df_neutral["p"][(df_neutral["freq"] > freq_boundaries[i]) &
#                                  (df_neutral["freq"] <= freq_boundaries[i+1])]
#     sample_size_freq.append(len(p_category))
#     # Neutral mutations have no phenotypic effect and therefore no positive
#     mut_in_cat = len(p_category)
#     obsP_neutral = p_category < 0.05
#     # All positives are false positives
#     FP = sum(obsP_neutral)
#     FPR_neutral_byFreq_equalWidth.append(FP/mut_in_cat)


#### More Plots ####

# Histogram of non-0 LF_mut
plt.hist(delta_LF_mut[delta_LF_mut != 0], bins=100,
         color="grey")
plt.xlabel("$LF_{mut}$")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_non0LFhist.png",
            dpi=300)
plt.close()

# Display the average fitness of local and foreign populations
plt.figure(1)
plt.boxplot([w_local, w_foreign],
            labels=["Local", "Foreign"])
plt.xlabel("Groups")
plt.ylabel("Average relative fitness")
# plt.show()
plt.savefig(figPath + str(model_name) + "_test_localAdapt.png",
            dpi=300)
plt.close()

# Cumulative plot of LF_mut
expected_explained_proportion = 0.8
sorted_lfmut = np.array(list(reversed(sorted(delta_LF_mut_positveLFandAge))))
positiveTotal = sum(sorted_lfmut)
cumulative_lf = [0] + [sum(sorted_lfmut[0:k+1])/positiveTotal
                       for k in range(len(sorted_lfmut))]
# How many alleles do we need to account for 80% of current local adaptation?
gea_goal = sum(np.array(cumulative_lf) < expected_explained_proportion)
explained = cumulative_lf[gea_goal]
plt.plot(range(len(sorted_lfmut)+1), cumulative_lf,
         color="lightseagreen")
plt.xlabel("Mutations sorted in descending order of $LF_{mut}$")
plt.ylabel("Cumulative proportion of positive LF")
# plt.axvline(x=gea_goal, color="firebrick", linestyle="dotted")
# plt.axhline(y=explained, color="firebrick", linestyle="dotted")
plt.plot([gea_goal, gea_goal], [0, explained],
         color="firebrick", linestyle="dotted")
plt.plot([0, gea_goal], [explained, explained],
         color="firebrick", linestyle="dotted")
plt.annotate(str(gea_goal), xy=(gea_goal+1, explained),
             xytext=(gea_goal + 1 + len(cumulative_lf)/40, 0),
             color="firebrick")
plt.savefig(figPath + model_name + "_LFcumulative_positive.png",
            dpi=300)
plt.close()

# print("Selected figures saved")
# print(time.ctime())

# # Histogram of positive LF
# plt.hist(delta_LF_mut[delta_LF_mut > 0], bins=100,
#          color="grey")
# # plt.title("With local adapation")
# plt.xlabel("$LF_{mut}$")
# plt.ylabel("Count")
# plt.savefig(figPath+model_name+"_LFhist_positive.png",
#             dpi=300)
# plt.close()

# # LF ~ phenotypic effect size
# plt.plot(abs(mut_effect), delta_LF_mut,
#          marker="o", linestyle="",
#          color="saddlebrown", alpha=0.1)
# plt.xlabel("|Phenptypic effect size|")
# # plt.ylabel("$LF_{mutation}$ (ln)")
# plt.ylabel("$LF_{mutation}$")
# # plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
# #             dpi=100)
# plt.savefig(figPath+model_name+"continuousWF_phenoEffectAndLF.png",
#             dpi=300)
# plt.close()

# LF ~ |phenotypic effect size|
age_rank_bin = (age.argsort().argsort()/10000).astype(int)
plt.scatter(abs(mut_effect), delta_LF_mut,
            marker="o",
            c=age_rank_bin, alpha=0.2)
plt.xlabel("|Phenotypic effect size|")
plt.ylabel("$LF_{mut}$")
plt.colorbar().set_label("Age rank bins \n (10000 alleles per bin)")
plt.tight_layout()
plt.savefig(figPath+model_name+"_phenoEffectAndLF_ageRankColor.png",
            dpi=300)
plt.close()



# total LF of the size ~ |phenotypic effect size|
# total LF of the size ~ |phenotypic effect size|, separating positive and negative parts

num_cat = 10 # Number of categories for allele age
abs_effect = abs(mut_effect)
LF_total = sum(delta_LF_mut)
LF_positive = sum(delta_LF_mut[delta_LF_mut>0])
LF_negative = sum(delta_LF_mut[delta_LF_mut<0])
lf_sum = []
lf_sum_positive = []
lf_sum_negative = []
alpha_cats = np.append(np.arange(0, max(abs_effect), max(abs_effect)/num_cat),
                       max(abs_effect))
for i in range(num_cat):
    lf_category = delta_LF_mut[np.logical_and(abs_effect > alpha_cats[i],
                                              abs_effect <= alpha_cats[i+1])]
    lf_sum.append(sum(lf_category/LF_total))
    lf_sum_positive.append(sum(lf_category[lf_category > 0]) / LF_total)
    lf_sum_negative.append(sum(lf_category[lf_category < 0]) / LF_total)

#total LF of the size ~ |phenotypic effect size|
plt.figure(1)
plt.plot(alpha_cats[1:],
         lf_sum,
         color="grey")
plt.xlabel("|Mutation phenotypic effect size|")
plt.ylabel("Relative contribution to local adaptation from the size class")
# plt.xticks(ticks=np.arange(100/num_cat, 101, 100/num_cat),
#            labels=[(str(i*cat_width)+"-"+str((i+1)*cat_width))
#                    for i in range(num_cat)])
plt.tight_layout()
plt.savefig(figPath+model_name+"_"+str(num_cat) + "bins"+
            "_LF_by_absEffectSize_bin.png",
            dpi=300)
plt.close()

# total LF of the size ~ |phenotypic effect size|, separated by positive and
# negative contributions
plt.figure(1)
lf_sum_positive = np.array(lf_sum_positive)
lf_sum_negative = np.array(lf_sum_negative)
x = alpha_cats[1:]
y1 = lf_sum_positive
y2 = lf_sum_negative
fig, ax = plt.subplots()
ax.plot(x, y1, color="mediumaquamarine",
        label="Positive")
ax.plot(x, y2, color="saddlebrown",
        label="Negative")
ax.axhline(0, color='grey', lw=1, dashes=(1,1))
plt.xlabel("|Mutation phenotypic effect size|")
plt.ylabel("Relative contribution to local from the size class")
ax.legend(loc="upper right")
ax.yaxis.set_major_formatter(lambda x, pos: f'{abs(x):g}')
ax.margins(x=0)
plt.savefig(figPath+model_name+"_"+str(num_cat) + "bins"+
            "_LF_by_absEffectSize_bin_positveAndnegative.png",
            dpi=300)
plt.close()


# Relative LF_mut by pos
fig, axs = plt.subplots(2, 1)
fig.set_figheight(9)
fig.set_figwidth(9)
LF_positive = sum(delta_LF_mut[delta_LF_mut>0])
# plot 0: TMRCA with the contribution of sites to local adaptation (delta LF)
# axs[0].stairs(tmrca_recap, kb_recap, baseline=None,
#            color="mediumaquamarine")
axs[0].plot(pos_by_mut/1000, delta_LF_mut/LF_positive,
         marker="o", linestyle="",
         color="mediumaquamarine", alpha=0.2)
# axs[0].set_title("$LF_{mutation}$")
# axs[0].set_xlabel("Genomic positions (kb)")
axs[0].set_ylabel("$LF_{mutation}$")
# axs[1].stairs(tmrca_recap, kb_recap, baseline=None,
#            color="mediumaquamarine")
axs[1].plot(pos_by_mut/1000, -np.log10(cor_GE[1]),
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.05)
# axs[1].set_title("-log10(p-value)")
axs[1].set_xlabel("Genomic positions (kb)")
axs[1].set_ylabel("-log10(p-value)")
plt.savefig(figPath+model_name+"_lfmut_gea_by_pos.png",
            dpi=300)
plt.close()

# # non-0 |LF| ~ allele age
# tempx = np.log(age[np.logical_and(delta_LF_mut != 0, age != 0)])
# tempy = np.log(np.abs(delta_LF_mut[np.logical_and(delta_LF_mut != 0, age != 0)]))
# res = stats.linregress(tempx, tempy)
# rsquared = round(res.rvalue ** 2, 3)
# slope = '{:0.2e}'.format(res.slope)
# linearp = '{:0.2e}'.format(res.pvalue)
# spr_abs = stats.spearmanr(tempx, tempy)
# plt.figure(1)
# plt.plot(tempx, tempy,
#          marker="o", linestyle="",
#          color="saddlebrown", alpha=0.1)
# plt.plot(sorted(tempx),
#          res.intercept + np.array(sorted(tempx))*res.slope,
#          color = "cornflowerblue")
# plt.text(0, min(tempy)+(max(tempy)-min(tempy))*0.9,
#          "$r^{2}$="+str(rsquared) + "\n" +
#          "P-value=" + str(linearp) + "\n" +
#          "Slope=" + str(slope),
#          color = "cornflowerblue")
# plt.xlabel("ln(Mutation age)")
# plt.ylabel("ln(|$LF_{mut})$|")
# plt.savefig(figPath+model_name+"_non0ageAndAbsoluteNon0LF_ln.png",
#             dpi=300)
# plt.close()


# Histogram of GEA p-values
plt.hist(cor_GE[1], bins=100,
         color="grey")
plt.xlabel("GEA p-values")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_GEA_pvalue_hist.png",
            dpi=300)
plt.close()

# Histogram of allele age
plt.hist(age, bins=100,
         color="grey")
plt.xlabel("Allele age")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_age_hist.png",
            dpi=300)
plt.close()

# Histogram of individual age
plt.hist(ind_age, bins=100,
         color="grey")
plt.xlabel("Individual age (ticks)")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_individual_age_hist.png",
            dpi=300)
plt.close()

np.median(ind_age)
np.mean(ind_age)
max(ind_age)

# Histogram of allele freq
plt.hist(freq, bins=100,
         color="grey")
plt.xlabel("Allele frequency")
plt.ylabel("Count")
plt.savefig(figPath+model_name+"_freq_hist.png",
            dpi=300)
plt.close()

# # Histogram of allele age of neutral alleles
# plt.hist(df_neutral["age"], bins=100,
#          color="grey")
# plt.xlabel("Allele age")
# plt.ylabel("Count")
# plt.savefig(figPath+model_name+"_age_hist_neutral.png",
#             dpi=300)
# plt.close()
#
# # Histogram of allele freq of neutral alleles
# plt.hist(df_neutral["freq"], bins=100,
#          color="grey")
# plt.xlabel("Allele frequency")
# plt.ylabel("Count")
# plt.savefig(figPath+model_name+"_freq_hist_neutral.png",
#             dpi=300)
# plt.close()

# Histogram of raw GEA p-values by allele age
# Also calculate the proportion of significant (FDR < 0.05) alleles in each age category,
# using p-values adjusted with Benjamini-Hochberg method
num_cat = 10
age_percentile = np.percentile(age, np.append(np.arange(0, 100, num_cat),100))
# k = 0
proportion_sig = []
for i in range(num_cat):
    # k += len(cor_GE[1][np.logical_and(age > age_percentile[i],
    #                                   age <= age_percentile[i+1])])
    p_category = cor_GE[1][np.logical_and(age > age_percentile[i],
                                      age <= age_percentile[i+1])]
    # p_BH_category = p_BH[np.logical_and(age > age_percentile[i],
    #                                   age <= age_percentile[i+1])]
    num_allele = len(p_category)
    # proportion_sig.append(sum(p_BH_category < 0.05)/num_allele)
    proportion_sig.append(sum(p_category < 0.05) / num_allele)
    plt.hist(p_category,
             bins=100,
             color="grey")
    plt.xlabel("GEA p-values")
    plt.ylabel("Count")

    plt.title("Bin " + str(i) + ": \n " +
              "age " +str(int(age_percentile[i])) +
              "-" + str(int(age_percentile[i+1])))
    plt.savefig(figPath+model_name+"_GEA_pvalue_hist_byAge_bin"+str(i)+".png",
                dpi=300)
    plt.close()
# print(k)



# Proportion of significant alleles ~ age percentile bin
num_cat = 10
plt.plot(np.arange(100/num_cat, 110, 100/num_cat),
         proportion_sig,
         color="grey")
plt.xlabel("Allele age percentile bins")
# plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
plt.ylabel("Proportion of alleles with p-value < 0.05")
plt.xticks(ticks=np.arange(100/num_cat, 110, 100/num_cat),
           labels=[(str(i*10)+"-"+str(i*10+10)) for i in range(10)])
plt.savefig(figPath+model_name+"_proportionGEArawP_vs_age.png",
            dpi=300)
plt.close()


# # Histogram of GEA tau
# plt.hist(cor_GE[0], bins=100,
#          color="grey")
# plt.xlabel("GEA Kendall's tau")
# plt.ylabel("Count")
# plt.savefig(figPath+model_name+"_GEA_tau_hist.png",
#             dpi=300)
# plt.close()

# # GEA p-value ~ Allele age
# plt.scatter(age, cor_GE[1],
#          marker="o",
#          c="grey", alpha=0.05)
# plt.xlabel("Allele age")
# plt.ylabel("GEA p-values")
# # plt.colorbar().set_label("$LF_{mut}$")
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_GEApvalue_vs_age.png",
#             dpi=300)
# plt.close()

# # |GEA Kendall's tau| ~ Allele age
# plt.scatter(age, abs(cor_GE[0]),
#          marker="o",
#          c="grey", alpha=0.05)
# plt.xlabel("Allele age")
# plt.ylabel("|GEA Kendall's tau|")
# # plt.colorbar().set_label("$LF_{mut}$")
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_absGEATau_vs_age.png",
#             dpi=300)
# plt.close()

# # Allele frequency ~ Allele age
# plt.scatter(age, freq,
#          marker="o",
#          # c=cor_GE[1], alpha=0.05)
#          c="grey", alpha = 0.05)
# plt.xlabel("Allele age")
# plt.ylabel("Allele frequency")
# # plt.colorbar().set_label("GEA p-values")
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_freq_vs_age.png",
#             dpi=300)
# plt.close()


# Relative LF_mut ~ cor_GE p-values, colored by log10(age)
plt.scatter(cor_GE[1], delta_LF_mut/LF_positive,
            marker="o",
            c=np.log10(age), alpha=0.2)
plt.xlabel("GEA p-values")
plt.ylabel("Relative $LF_{mut}$")
plt.colorbar().set_label("log10(allele age)")
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_relativeLFmut_log10ageColor.png",
            dpi=300)
plt.close()

# Relative LF_mut ~ cor_GE p-values RANKS, colored by age rank bins
p_rank = cor_GE[1].argsort().argsort()
age_rank_bin = (age.argsort().argsort()/10000).astype(int)
plt.scatter(p_rank, delta_LF_mut/LF_positive,
         marker="o",
         c=age_rank_bin, alpha=0.2)
plt.xlabel("GEA p-values ranks")
plt.ylabel("Relative $LF_{mut}$")
plt.colorbar().set_label("Age rank bins \n (10000 alleles per bin)")
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalueRank_vs_relativeLFmut_ageBinColor.png",
            dpi=300)
plt.close()



# By allele age bins
# Relative LF_mut ~ cor_GE p-values RANKS
num_cat = 10
age_percentile = np.percentile(age,
                               np.append(np.arange(0, 100, num_cat),
                                         100))
lf_min = min(delta_LF_mut/LF_positive)
lf_max = max(delta_LF_mut/LF_positive)
for i in range(num_cat):
    p_category = cor_GE[1][np.logical_and(age > age_percentile[i],
                                          age <= age_percentile[i+1])]
    p_category_rank = p_category.argsort().argsort()
    delta_LF_mut_category = delta_LF_mut[
        np.logical_and(age > age_percentile[i],
                       age <= age_percentile[i + 1])
    ]
    relative_LF_mut = delta_LF_mut_category/LF_positive
    # p_BH_category = p_BH[np.logical_and(age > age_percentile[i],
    #                                   age <= age_percentile[i+1])]
    num_allele = len(p_category)
    # proportion_sig.append(sum(p_category < 0.05) / num_allele)
    plt.scatter(p_category_rank, relative_LF_mut,
                marker="o",
                c="grey", alpha=0.2)
    plt.ylim(lf_min*1.10, lf_max*1.05)
    plt.xlabel("GEA p-values ranks")
    plt.ylabel("Relative $LF_{mut}$")
    plt.title("Rank bin" + str(i))
    plt.tight_layout()
    plt.savefig(figPath + model_name + "AgeBin" + str(i) +
                "_corGEpvalueRank_vs_relativeLFmut.png",
                dpi=300)
    plt.close()

# # ln(positive LF_mut) ~ ln(cor_GE p-values), colored by age
# # Remove negative LF values and 0 allele age for some plots
# positive_lfmut_age = age[delta_LF_mut > 0]
# positive_lfmut = delta_LF_mut[delta_LF_mut > 0]
# positive_lfmut_gea = cor_GE[1][delta_LF_mut > 0]
# (tau, p) = stats.kendalltau(positive_lfmut_age, positive_lfmut)
#
# plt.scatter(np.log(positive_lfmut_gea), np.log(positive_lfmut),
#          marker="o",
#          c=positive_lfmut_age, alpha=0.2)
# plt.xlabel("ln(GEA p-values)")
# plt.ylabel("ln($LF_{mut}$)")
# plt.colorbar()
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_ageColor_positveLn.png",
#             dpi=300)
# plt.close()

#### Compare to the time of demographic history ####
# Histogram of raw GEA p-values by allele age: before/after expansion
num_phase = 2
# age_timeCat = np.array([0.0, 10000, max(age)])
boundary = current_tick - history
age_timeCat = np.array([0.0, boundary, max(age)])
k = 0
proportion_sig = []
names = ["After heterogeneous selection", "Before heterogeneous selection"]
lf_min = min(delta_LF_mut/LF_positive)
lf_max = max(delta_LF_mut/LF_positive)
for i in range(num_phase):
    p_category = cor_GE[1][np.logical_and(age > age_timeCat[i],
                                      age <= age_timeCat[i+1])]
    print()
    # p_BH_category = p_BH[np.logical_and(age > age_timeCat[i],
    #                                   age <= age_timeCat[i+1])]
    p_category_rank = p_category.argsort().argsort()
    delta_LF_mut_category = delta_LF_mut[
        np.logical_and(age > age_timeCat[i],
                       age <= age_timeCat[i + 1])
    ]
    relative_LF_mut_category = delta_LF_mut_category / LF_positive

    # p-value histograms by time phases
    plt.hist(p_category,
             bins=100,
             color="grey")
    plt.xlabel("GEA p-values")
    plt.ylabel("Count")
    plt.title(names[k])
    plt.savefig(figPath+model_name+"_GEA_pvalue_hist_byAgePhases"+str(i)+".png",
                dpi=300)
    plt.close()
    # Scatter plots by time phases: LF_mut～p-value
    plt.scatter(p_category_rank, relative_LF_mut_category,
                marker="o",
                c="grey", alpha=0.2)
    plt.ylim(lf_min * 1.10, lf_max * 1.05)
    plt.xlabel("GEA p-values ranks")
    plt.ylabel("Relative $LF_{mut}$")
    plt.title(names[k])
    plt.tight_layout()
    plt.savefig(figPath + model_name + "_byAgePhases" + str(i) +
                "_corGEpvalueRank_vs_relativeLFmut.png",
                dpi=300)
    plt.close()
    k += 1


plt.scatter(abs(cor_GE[0]), delta_LF_mut,
         marker="o",
         c=np.log10(age), alpha=0.2)
plt.xlabel("|GEA Kendall's tau|")
plt.ylabel("$LF_{mut}$")
plt.colorbar().set_label("log10(allele age)")
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEcoef_vs_LF_mut_log10ageColor.png",
            dpi=300)
plt.close()

# # Check the distribution of mutation with largest LF_mut
# np.nanargmax(delta_LF_mut)
# maxlf_mut = np.reshape(freq_sample_pop[np.nanargmax(delta_LF_mut)],
#                        (10, 10))
# # Plot
# fig, ax = plt.subplots()
# im = ax.imshow(maxlf_mut)
# plt.savefig(figPath+model_name+"_maxLF_distribute.png",
#             dpi=300)
# plt.close()
#
# #Check the distribution of the mutation with most significant cor_GE
# np.nanargmin(cor_GE[1])
# minp_mut = np.reshape(freq_sample_pop[np.nanargmin(cor_GE[1])],
#                       (10, 10))
# #Plot
# fig, ax = plt.subplots()
# im = ax.imshow(minp_mut)
# plt.savefig(figPath+model_name+"_min_p_distribute.png",
#             dpi=300)
# plt.close()

# Allele frequencies
# LF_mut ~ cor_GE p-values, colored by Allele frequencies
plt.scatter(cor_GE[1], delta_LF_mut,
         marker="o",
         c=freq, alpha=0.2)
plt.xlabel("GEA p-values")
plt.ylabel("$LF_{mut}$")
plt.colorbar().set_label("Allele frequency")
plt.tight_layout()
plt.savefig(figPath+model_name+"_corGEpvalue_vs_LF_mut_freqColor.png",
            dpi=300)
plt.close()

# # TPR ～ Allele age
# plt.plot(np.arange(100/num_cat, 101, 100/num_cat),
#          TPR,
#          color="grey")
# plt.xlabel("Allele age percentile bins")
# # plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
# plt.ylabel("True positive rate (TP/(TP+FN))")
# plt.xticks(ticks=np.arange(100/num_cat, 101, 100/num_cat),
#            labels=[(str(i*cat_width)+"-"+str((i+1)*cat_width))
#                    for i in range(num_cat)])
# # plt.savefig(figPath+model_name+"_proportionGEABHp_vs_age.png",
# #             dpi=300)
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_minLF"+str(LF_min)+"_"+
#             str(num_cat)+"bins"+"_TPR_lfmut1percent_GEABHp0.05_vs_age.png",
#             dpi=300)
# plt.close()
#
# # FPR ～ Allele age
# plt.plot(np.arange(100/num_cat, 101, 100/num_cat),
#          FPR,
#          color="grey")
# plt.xlabel("Allele age percentile bins")
# # plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
# plt.ylabel("False positive rate (FP/(FP+TN)))")
# plt.xticks(ticks=np.arange(100/num_cat, 101, 100/num_cat),
#            labels=[(str(i*cat_width)+"-"+str((i+1)*cat_width))
#                    for i in range(num_cat)])
# # plt.savefig(figPath+model_name+"_proportionGEABHp_vs_age.png",
# #             dpi=300)
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_minLF"+str(LF_min)+"_"+
#             str(num_cat)+"bins"+"_FPR_lfmut1percent_GEABHp0.05_vs_age.png",
#             dpi=300)
# plt.close()
#
# # Neutral alleles: FPR ～ Allele age, equal number alleles per bin
# plt.plot(np.arange(100/num_cat, 101, 100/num_cat),
#          FPR_neutral_byAge,
#          color="grey")
# plt.xlabel("Allele age percentile bins")
# # plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
# plt.ylabel("False positive rate of neutral alleles (FP/(FP+TN))")
# plt.xticks(ticks=np.arange(100/num_cat, 101, 100/num_cat),
#            labels=[(str(i*cat_width)+"-"+str((i+1)*cat_width))
#                    for i in range(num_cat)])
# # plt.savefig(figPath+model_name+"_proportionGEABHp_vs_age.png",
# #             dpi=300)
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_"+
#             str(num_cat)+"bins"+"_FPR_GEAp0.05_vs_age_neutralAllele.png",
#             dpi=300)
# plt.close()
#
# # Neutral alleles: FPR ～ Frequency, equal number alleles per bin
# plt_pos = np.arange(100/num_cat, 101, 100/num_cat)
# plt.plot(plt_pos,
#          FPR_neutral_byFreq,
#          color="grey")
# plt.xlabel("Allele frequency percentile bins")
# # plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
# plt.ylabel("False positive rate of neutral alleles (FP/(FP+TN))")
# # for i in range(10):
# #     label = "{:.5f}".format(freq_percentile[i])
# #     print(label)
# #     x = np.arange(100/num_cat-5, 100, 100/num_cat)[i]
# #     y = FPR_neutral_byFreq[i]
# #     plt.annotate(label,
# #                  (x,y))
# #                  # ,
# #                  # textcoords="offset points",
# #                  # xytext=(-0.5, 0.1))
# #     plt.xticks([], minor=False)
# # plt.savefig(figPath+model_name+"_proportionGEABHp_vs_age.png",
# #             dpi=300)
# plt.xticks(ticks=np.arange(100/num_cat, 101, 100/num_cat),
#            labels=[(str(i*cat_width)+"-"+str((i+1)*cat_width))
#                    for i in range(num_cat)])
# plt.tight_layout()
# plt.minorticks_off()
# plt.savefig(figPath+model_name+"_"+
#             str(num_cat)+"bins"+"_FPR_GEAp0.05_vs_freq_neutralAllele.png",
#             dpi=300)
# plt.close()
#
# # Neutral alleles: FPR ～ Allele age, equal intervals
# plt.plot(age_boundaries[0:-1] + cat_width_age/2,
#          FPR_neutral_byAge_equalWidth,
#          color="grey")
# plt.xlabel("Allele age")
# # plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
# plt.ylabel("False positive rate of neutral alleles (FP/(FP+TN))")
# plt.xticks(ticks=age_boundaries,
#            labels=[str(int(i)) for i in age_boundaries])
# # plt.savefig(figPath+model_name+"_proportionGEABHp_vs_age.png",
# #             dpi=300)
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_"+
#             str(num_cat)+"bins"+"_FPR_GEAp0.05_vs_age_neutralAllele_equalInterval.png",
#             dpi=300)
# plt.close()
#
# # Neutral alleles: FPR ～ Freq, equal intervals
# plt.plot(freq_boundaries[0:-1] + cat_width_freq/2,
#          FPR_neutral_byFreq_equalWidth,
#          color="grey")
# plt.xlabel("Allele frequency")
# # plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
# plt.ylabel("False positive rate of neutral alleles (FP/(FP+TN))")
# plt.xticks(ticks=freq_boundaries,
#            labels=[str(i) for i in freq_boundaries])
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_"+
#             str(num_cat)+"bins"+"_FPR_GEAp0.05_vs_freq_neutralAllele_equalInterval.png",
#             dpi=300)
# plt.close()
#
#
# # FDR ～ Allele age
# plt.plot(np.arange(100/num_cat, 101, 100/num_cat),
#          FDR,
#          color="grey")
# plt.xlabel("Allele age percentile bins")
# # plt.ylabel("Proportion of alleles with BH-adjusted p-value < 0.05")
# plt.ylabel("False discovery rate (FP/(FP+TP)))")
# plt.xticks(ticks=np.arange(100/num_cat, 101, 100/num_cat),
#            labels=[(str(i*cat_width)+"-"+str((i+1)*cat_width))
#                    for i in range(num_cat)])
# # plt.savefig(figPath+model_name+"_proportionGEABHp_vs_age.png",
# #             dpi=300)
# plt.tight_layout()
# plt.savefig(figPath+model_name+"_minLF"+str(LF_min)+"_"+
#             str(num_cat)+"bins"+"_FDR_lfmut1percent_GEABHp0.05_vs_age.png",
#             dpi=300)
# plt.close()
