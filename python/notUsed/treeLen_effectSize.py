"""Explore how the shape of coalescent trees are shaped by local adaptation
with different distribution of mutation phenotypic effect size
For tree sequences generated by CONTINUOUS SPACE models in SLiM
No need for recapitation: Neutral coalescent history has been added with
msprime before SLiM simulation
tianlin.duan42@gmail.com
2024.01.22
"""

############################# modules #########################################
# import msprime
# import pyslim
import tskit
import matplotlib.pyplot as plt
import scipy.stats as stats
from scipy.spatial import distance_matrix
import numpy as np
from time import time

############################# functions #######################################
def tree_heights(ts):
    kb = [0]
    mrca_t = []
    for tree in ts.trees():
        kb.append(tree.interval.right / 1000)
        if tree.has_multiple_roots:
            # Use the maximum time when not coalesced
            mrca_t.append(ts.metadata["SLiM"]["tick"])
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            mrca_t.append(tree.time(real_root))
    return mrca_t, kb

def tree_height(tree, max_tick):
    if tree.has_multiple_roots:
        # Use the maximum time when not coalesced
        tmrca = (max_tick)
    else:
        children = tree.children(tree.root)
        real_root = tree.root if len(children) > 1 else children[0]
        tmrca = (tree.time(real_root))
    return tmrca

def LF_fitness_loop(ind_x, ind_y, phenotype, optimal, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        optimal of the localtion of each individual(array-like),
        a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return an array of the difference of average fitness of local and foreign individuals.
    v1: memory efficient but not time efficient
    """
    w_foreign = []
    w_local = []
    for i in range(len(ind_x)):
        dist = np.sqrt((ind_x - ind_x[i]) ** 2 + (ind_y - ind_y[i]) ** 2)
        w_all = 1.0 + stats.norm.pdf(phenotype, optimal[i], sigma_w)
        w_relative = np.array(w_all / np.mean(w_all))
        w_foreign.append(np.mean(w_relative[dist > dist_mate]))
        w_local.append(np.mean(w_relative[dist <= dist_mate]))
    return np.array(w_local), np.array(w_foreign)

def LF_fitness(ind_x, ind_y, phenotype,
               optimal, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        environmental optimals (array-like), a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return two arrays of the average fitness of local and foreign individuals, respectively.
    v2: time efficient but not memory efficient.
    Try the other version when the number of individuals is large.
    """
    optimal=np.array(optimal)
    coord = list(zip(ind_x, ind_y))
    dist_matrix = distance_matrix(coord, coord)
    isLocal_matrix = dist_matrix <= dist_mate
    # Calculate fitness matrix (w_matrix[i][j]: individual j at location i) with broadcast
    w_matrix = 1.0 + stats.norm.pdf(np.array(phenotype),
                                    np.array(optimal)[:, np.newaxis],
                                    sigma_w)
    # relative fitness
    w_matrix = w_matrix / np.mean(w_matrix, 1)[:, np.newaxis]
    #Average relative fitness of local and foreign individuals
    w_local = np.mean(np.ma.masked_array(w_matrix, np.invert(isLocal_matrix)), 1)
    w_foreign = np.mean(np.ma.masked_array(w_matrix, isLocal_matrix), 1)
    return w_local, w_foreign

############################# program #########################################
#Values
sigma_w = 0.4
dist_mate = 0.1
model_name = "contiuous_nonWF_M2_1.4_5000generation_notreeSeqRememberIndividuals_seed18193409761929481905000_sigmaM0.8"
#model_name = "contiuous_nonWF_M2_1.4_sigmaM0.1_standingMu1e9"
# inDir = "D:/UBC_office/slim/output/"
inDir = "/home/tianlin/Documents/github/data/slim_data/"
outDir = "/home/tianlin/Documents/github/data/tskit_data/output/"
figureDir = "/home/tianlin/Documents/github/data/tskit_data/figure/"

# Tree-sequence file from SLiM
#ts = tskit.load(inDir + "Continuous_nonWF_M2_sigma_M0.8_seed_4358486947916021379.trees")
# ts = tskit.load(inDir + "Continuous_nonWF_M2_sigma_M0.4_seed_3909403400996992410.trees")
# ts = tskit.load(inDir + "Continuous_nonWF_M2_sigma_M0.8_seed_18193409761929481905000generation.trees")
ts = tskit.load(inDir + "Continuous_nonWF_M2_sigma_M0.8_seed_24430206304517413725000generation_norememberInd.trees")
# ts = tskit.load(inDir + "Continuous_nonWF_M2_sigma_M0.8_seed_12886065033900836275000generation.trees")
# ts = tskit.load(inDir + "Continuous_nonWF_M2_sigma_M0.8_seed_17272808088647008265000generation.trees")
# ts = tskit.load(inDir + "Continuous_nonWF_M2_sigma_M0.2_seed_2699528280388232063.trees")
# ts = tskit.load(inDir + "Continuous_nonWF_M2_sigma_M0.1_seed_4028907423616427904.trees")
# ts = tskit.load(inDir + "Continuous_nonWF_M0_sigma_M0.8_seed_1720465873480116299.trees")

ind_x, ind_y, ind_z = zip(*ts.individuals_location)
phenotype = ts.individuals
# Genomic position of sites
pos = ts.sites_position
# Genomic position of mutations
pos_by_mut = ts.sites_position[ts.mutations_site]
# Maximum tick
max_tick = ts.metadata["SLiM"]["tick"]
# Number of diploid individuals
N = ts.num_individuals
# Environmental optimal
optimal = np.array(ind_x)
# Tree length
(tmrca, kb) = tree_heights(ts)

# Phenotypic effect of each mutation
# 1-dimensional
mut_effect = []
for mut in ts.mutations():
    mut_effect.append(mut.metadata['mutation_list'][0]['selection_coeff'])
mut_effect = np.array(mut_effect)

# 2-dimensional: list of lists, corresponding to phenotypic effect of allele 0/1/2... at each site
mut_effect_lists = []
for site in ts.sites():
    effect_site = [0]
    for mut in site.mutations:
        effect_site.append(mut.metadata['mutation_list'][0]['selection_coeff'])
    mut_effect_lists.append(effect_site)

# Observed extent of local adaptation (local-foreign contrast (LF))
(w_local, w_foreign) = LF_fitness(ind_x, ind_y, ind_z,
                                  optimal, dist_mate, sigma_w)
LF_cline = w_local - w_foreign
mean_LF = np.mean(LF_cline)

print(mean_LF)
plt.figure(1)
plt.boxplot([w_local, w_foreign],
            labels=["Local", "Foreign"])
plt.xlabel("Groups")
plt.ylabel("Average relative fitness")
# plt.show()
plt.savefig(figureDir + model_name + "_test_localAdapt.png")
plt.close()

# Contribution of each mutation to LFï¼š takes a long time
index_site = 0
LF_without_mut = []
t = time()
for v in ts.variants():
    # Calculate the effect of each mutation at the focal site
    index_gt = 1
    while index_gt < len(mut_effect_lists[index_site]):
        #hide other mutations except the focal mutation
        focal_gt = np.array(v.genotypes)
        focal_gt[focal_gt != index_gt] = 0
        # effect of the focal mutation in each individual
        effect_mut_genomes = np.array(mut_effect_lists[index_site])[focal_gt]
        # Add up two genomes of each individual
        effect_mut_ind = (effect_mut_genomes[range(0, 2*N-1, 2)]
                        + effect_mut_genomes[range(1, 2*N, 2)])
        # Phenotype without the mut = phenotypes of each ind - effect of the focal mutation in each ind
        phenotype_without_mut = ind_z - effect_mut_ind
        (w_local, w_foreign) = LF_fitness(ind_x, ind_y, phenotype_without_mut,
                                          ind_x, dist_mate, sigma_w)
        LF_without_mut.append(np.mean(w_local-w_foreign))
        index_gt += 1
    index_site += 1
    if index_site % 100 == 0:
        print(f"{index_site} sites processed")
delta_LF_mut = mean_LF-LF_without_mut
# Elapsed Time
timer = time() - t
print(timer/60)
# 35.7 on laptop
# 19.1 on office dell

# Save the contribution of each mutation to LF
with open(outDir + model_name + "delta_LF_mut.txt", "w") as fout:
    for item in delta_LF_mut:
        fout.write(str(item) + "\n" )
fout.close()


# Load LF from file
delta_LF_mut = np.loadtxt(outDir + model_name + "delta_LF_mut.txt")

# Age of each mutation
age = ts.mutations_time
pos_by_mut = ts.sites_position[ts.mutations_site]
effect_by_mut = []
for site in ts.sites():
    for mut in site.mutations:
        effect_by_mut.append(mut.metadata['mutation_list'][0]['selection_coeff'])
effect_by_mut = np.array(effect_by_mut)

# TMRCA of all samples at the position of each mutation
tmrca_mut = []
for p in pos_by_mut:
    tmrca_mut.append(tree_height(ts.at(p), max_tick))

'''
# Pairwise env diff and pairwise TMRCA
# V2: with subsampling
# n individuals nearest to the n percentiles of environmental optimal
n = 200 # sample size
env_qt = np.percentile(optimal, np.arange(0, 100, 100/n),
                       method="nearest")
subsample_ind_id = []
for q in env_qt:
    subsample_ind_id = np.append(subsample_ind_id, np.where(ind_x == q))
subsample_ind_id = subsample_ind_id.astype(int)
# Transform individual id to genome id
subsample_id = subsample_ind_id.repeat(2)*2 + np.tile([0,1], reps=n)

# Env diff matrix between pairwise individuals: n * n
envDiff_ind_matrix = abs(env_qt[:, np.newaxis] - env_qt)
# Zoom to a matrix for genomes (nodes at tip): 2n * 2n
envDiff_node_matrix = envDiff_ind_matrix.repeat(2,0).repeat(2,1)

# Pairwise TMRCA matrix by tree
t = time()
n2 = n*2
cor_list = np.zeros(shape=(ts_recap.num_trees, 2))
tree_id = 0
for tree in ts_recap.trees():
    tmrca_matrix = np.zeros(shape=(n2, n2))
    # tmrca_matrix = tree.tmrca(ts.samples()[:, np.newaxis], ts.samples()) # tmrca does not take array
    for i in np.arange(n2):
        for j in np.arange(n2):
            tmrca_matrix[i,j] = tree.tmrca(subsample_id[i], subsample_id[j])
    # Save the correlation between pair-wise env matrix and TMRCA matrix
    cor_list[tree_id, 0], cor_list[tree_id, 1] = stats.spearmanr(envDiff_node_matrix,
                                                                 tmrca_matrix,
                                                                 axis=None)
    tree_id += 1
timer = time() - t
print(timer/60)


plt.stairs(cor_list[:,0], breakPoints_recap/1000)
plt.stairs(LF_block_list, breakPoints_recap/1000)
#plt.show()
plt.xlabel("Genomic positions (kb)")
plt.savefig("output/continuousWF_localAdapt_corEnvDiffTMRCA_LFblock_recap.png",
            dpi=300)

plt.scatter(cor_list[:,0], LF_block_list,
            marker="o",
            c="saddlebrown", alpha=0.2)
plt.xlabel("$LF_{block}$")
plt.ylabel("cor_ET")
plt.savefig("output/continuousWF_localAdapt_corEnvDiffTMRCA_LFblock_recap_scatter.png",
            dpi=300)
stats.spearmanr(cor_list[:,0], LF_block_list)
'''

#### Plots ####
'''
#Tree height with LF mut
plt.figure(figsize=(24,1))
plt.stairs(tmrca, kb, baseline=None,
           color="mediumaquamarine")
plt.plot(pos_by_mut/1000, delta_LF_mut*1e6,
          marker="o", linestyle="",
          color="saddlebrown", alpha=0.1)
plt.savefig(figureDir + model_name + "_treeHeight_recap_LFmut.png",
            dpi=150)
plt.close()
'''

np.corrcoef(tmrca, delta_LF_mut)

# Hist LF
plt.hist(delta_LF_mut, bins=100,
         color="grey")
plt.xlabel("$LF_{mutation}$")
plt.ylabel("Count")
plt.savefig(figureDir + model_name + "_ageAndLF_LFhist.png",
            dpi=300)
plt.close()

# Hist positive LF
# Remove negative LF values and 0 allele age for some plots
tempx = age[np.logical_and(delta_LF_mut > 0, age > 0)]
tempy = delta_LF_mut[np.logical_and(delta_LF_mut > 0, age > 0)]
tempx_log = np.log(tempx)
tempy_log = np.log(tempy)
res = stats.linregress(tempx_log, tempy_log)
spr = stats.spearmanr(age, delta_LF_mut)
spr_positive = stats.spearmanr(tempx, tempy)

plt.hist(tempy, bins=100,
         color="grey")
# plt.title("With local adapation")
plt.xlabel("$LF_{mutation}$")
plt.ylabel("Count")
plt.savefig(figureDir + model_name + "_LFhist_positive.png",
            dpi=300)
plt.close()

# Cumulative plot
sorted_lfmut = np.array(sorted(tempy))
positiveTotal = sum(sorted_lfmut)
cumulative_lf = [sum(sorted_lfmut[0:k+1])/positiveTotal for k in range(len(sorted_lfmut))]
plt.plot(range(len(sorted_lfmut)), cumulative_lf)
plt.xlabel("Mutations sorted by LFmut")
plt.ylabel("Cumulative positive LF")
plt.savefig(figureDir + model_name + "_LFcumulative_positive.png",
            dpi=300)
plt.close()

# LF ~ phenotypic effect size
plt.plot(abs(mut_effect), delta_LF_mut,
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.1)
plt.xlabel("|Phenptypic effect size|")
# plt.ylabel("$LF_{mutation}$ (ln)")
plt.ylabel("$LF_{mutation}$")
# plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
#             dpi=100)
plt.savefig(figureDir + model_name + "_phenoEffectAndLF.png",
            dpi=300)
plt.close()

# LF ~ allele age
#np.seterr(divide = 'ignore')
plt.figure(1)
plt.plot(tempx_log, tempy_log,
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.1,
         label="Spearman's rho: "+str(spr)+"\n" + "p-value: 2.66e-22")
# plt.plot(tempx_log, res.intercept + tempy_log*res.slope,
#          color = "cornflowerblue")
# plt.axline((0,res.intercept),
#            slope=res.slope, color="cornflowerblue",
#            label = "")
# plt.title("With local adapation")
plt.xlabel("Mutation age (ln)")
plt.ylabel("$LF_{mutation}$ (ln)")
#plt.xscale("linear")
#plt.yscale("linear")
plt.savefig(figureDir + model_name + "_ageAndLF_ln.png",
            dpi=300)
plt.close()

# LF ~ pheno effect size, colored by age
plt.scatter(abs(mut_effect), np.log(delta_LF_mut),
         marker="o",
         c=age, alpha=0.2)
plt.xlabel("|Phenptypic effect size|")
plt.ylabel("$LF_{mutation}$ (ln)")
plt.colorbar()
# plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
#             dpi=100)
plt.savefig(figureDir + model_name + "_phenoEffectAndLF_ln_ageColor.png",
            dpi=300)
plt.close()

# Tree height ~ LF_mut
plt.scatter(np.log(tmrca_mut), np.log(delta_LF_mut),
         marker="o",
         c=age, alpha=0.2)
plt.ylabel("$LF_{mutation}$ (ln)")
plt.xlabel("TMRCA at the position (ln)")
plt.colorbar()
# plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
#             dpi=100)
plt.savefig(figureDir + model_name + "_LFAndTMRCA_ageColor.png",
            dpi=300)
plt.close()