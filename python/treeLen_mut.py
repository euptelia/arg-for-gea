"""Explore how the shape of coalescent trees are shaped by selection
For tree sequences generated by CONTINUOUS SPACE models in SLiM
"""

############################# modules #########################################
# import msprime
import tskit
import pyslim
import matplotlib.pyplot as plt
import scipy.stats as stats
from scipy.spatial import distance_matrix
import numpy as np
from time import time

############################# functions #######################################
def tree_heights(ts):
    kb = [0]
    mrca_t = []
    for tree in ts.trees():
        kb.append(tree.interval.right / 1000)
        if tree.has_multiple_roots:
            # Use the maximum time when not coalesced
            mrca_t.append(ts.metadata["SLiM"]["tick"])
        else:
            children = tree.children(tree.root)
            real_root = tree.root if len(children) > 1 else children[0]
            mrca_t.append(tree.time(real_root))
    return mrca_t, kb

def tree_height(tree, max_tick):
    if tree.has_multiple_roots:
        # Use the maximum time when not coalesced
        tmrca = (max_tick)
    else:
        children = tree.children(tree.root)
        real_root = tree.root if len(children) > 1 else children[0]
        tmrca = (tree.time(real_root))
    return tmrca

def LF_fitness_loop(ind_x, ind_y, phenotype, optimal, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        optimal of the localtion of each individual(array-like),
        a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return an array of the difference of average fitness of local and foreign individuals.
    v1: memory efficient but not time efficient
    """
    w_foreign = []
    w_local = []
    for i in range(len(ind_x)):
        dist = np.sqrt((ind_x - ind_x[i]) ** 2 + (ind_y - ind_y[i]) ** 2)
        w_all = 1.0 + stats.norm.pdf(phenotype, optimal[i], sigma_w)
        w_relative = np.array(w_all / np.mean(w_all))
        w_foreign.append(np.mean(w_relative[dist > dist_mate]))
        w_local.append(np.mean(w_relative[dist <= dist_mate]))
    return np.array(w_local), np.array(w_foreign)

def LF_fitness(ind_x, ind_y, phenotype,
               optimal, dist_mate, sigma_w):
    """Takes x and y coordinates (array-like), phenotypes (array-like),
        environmental optimals (array-like), a maximum distance for mating (single value),
        and a standard deviation of fitness function (single value).
    Return two arrays of the average fitness of local and foreign individuals, respectively.
    v2: time efficient but not memory efficient.
    Try the other version when the number of individuals is large.
    """
    optimal=np.array(optimal)
    coord = list(zip(ind_x, ind_y))
    dist_matrix = distance_matrix(coord, coord)
    isLocal_matrix = dist_matrix <= dist_mate
    # Calculate fitness matrix (w_matrix[i][j]: individual j at location i) with broadcast
    w_matrix = 1.0 + stats.norm.pdf(np.array(phenotype),
                                    np.array(optimal)[:, np.newaxis],
                                    sigma_w)
    # relative fitness
    w_matrix = w_matrix / np.mean(w_matrix, 1)[:, np.newaxis]
    #Average relative fitness of local and foreign individuals
    w_local = np.mean(np.ma.masked_array(w_matrix, np.invert(isLocal_matrix)), 1)
    w_foreign = np.mean(np.ma.masked_array(w_matrix, isLocal_matrix), 1)
    return w_local, w_foreign

############################# program #########################################
#Values
sigma_w = 0.4
dist_mate = 0.1
model_name = "Irwin2012_WFcline_slim_seed2538380779464636202"

# Tree-sequence file from SLiM
#ts = tskit.load("data/Irwin2012_WFcline_slim_seed1.trees")
ts = tskit.load("data/Irwin2012_WFcline_seed_2538380779464636202.trees")
# ts = tskit.load("data/Irwin2012_WFcline_slim_seed2.trees")
ind_x, ind_y, ind_z = zip(*ts.individuals_location)
# Genomic position of sites
pos = ts.sites_position
# Genomic position of mutations
pos_by_mut = ts.sites_position[ts.mutations_site]
# Maximum tick
max_tick = ts.metadata["SLiM"]["tick"]
# Number of diploid individuals
N = ts.num_individuals
# Environmental optimal
optimal = np.array(ind_x)


# Recapitation
ts_recap = pyslim.recapitate(ts, ancestral_Ne=5e3,
                             recombination_rate=5e-8,
                             random_seed=1)

(tmrca_recap, kb_recap) = tree_heights(ts_recap)

# Phenotypic effect of each mutation
# 1-dimensional
mut_effect = []
for mut in ts.mutations():
    mut_effect.append(mut.metadata['mutation_list'][0]['selection_coeff'])
mut_effect = np.array(mut_effect)

# 2-dimensional: list of lists, corresponding to phenotypic effect of allele 0/1/2... at each site
mut_effect_lists = []
for site in ts.sites():
    effect_site = [0]
    for mut in site.mutations:
        effect_site.append(mut.metadata['mutation_list'][0]['selection_coeff'])
    mut_effect_lists.append(effect_site)

# Observed extent of local adaptation (local-foreign contrast (LF))
# (w_local, w_foreign) = LF_fitness_loop(ind_x, ind_y, ind_z,
#                                   ind_x, dist_mate, sigma_w)
# print(timer1) # 3.608828544616699

(w_local, w_foreign) = LF_fitness(ind_x, ind_y, ind_z,
                                  optimal, dist_mate, sigma_w)
#print(timer2) # 1.456526279449463

LF_cline = w_local - w_foreign
mean_LF = np.mean(LF_cline)

print(mean_LF)
plt.figure(1)
plt.boxplot([w_local, w_foreign],
            labels=["Local", "Foreign"])
plt.xlabel("Groups")
plt.ylabel("Average relative fitness")
# plt.show()
plt.savefig("output/" + str(model_name) + "_test_localAdapt.png")
plt.close()

# Contribution of each mutation to LF
index_site = 0
LF_without_mut = []
t = time()
for v in ts.variants():
    # Calculate the effect of each mutation at the focal site
    index_gt = 1
    while index_gt < len(mut_effect_lists[index_site]):
        #hide other mutations except the focal mutation
        focal_gt = np.array(v.genotypes)
        focal_gt[focal_gt != index_gt] = 0
        # effect of the focal mutation in each individual
        effect_mut_genomes = np.array(mut_effect_lists[index_site])[focal_gt]
        # Add up two genomes of each individual
        effect_mut_ind = (effect_mut_genomes[range(0, 2*N-1, 2)]
                        + effect_mut_genomes[range(1, 2*N, 2)])
        # Phenotype without the mut = phenotypes of each ind - effect of the focal mutation in each ind
        phenotype_without_mut = ind_z - effect_mut_ind
        (w_local, w_foreign) = LF_fitness(ind_x, ind_y, phenotype_without_mut,
                                          ind_x, dist_mate, sigma_w)
        LF_without_mut.append(np.mean(w_local-w_foreign))
        index_gt += 1
    index_site += 1
    if index_site % 100 == 0:
        print(f"{index_site} sites processed")
delta_LF_mut = mean_LF-LF_without_mut
# Elapsed Time
timer = time() - t
print(timer/60)

# Save the contribution of each mutation to LF
with open("delta_LF_mut.txt", "w") as fout:
    for item in delta_LF_mut:
        fout.write(str(item) + "\n" )
fout.close()

# Load LF from file
# delta_LF_mut = []
# with open("delta_LF_mut.txt") as fin:
#     for line in fin:
#         delta_LF_mut.append(float(line.strip()))
# delta_LF_mut2 = np.array(delta_LF_mut2)
# fin.close()

delta_LF_mut = np.loadtxt("delta_LF_mut.txt")

# LF_block: Contribution of each genomic block to LF
# Load breakPoints
breakPoints = np.array([])
for b in ts.breakpoints():
    breakPoints = np.append(breakPoints, b)

breakPoints_recap = np.array([])
for b in ts_recap.breakpoints():
    breakPoints_recap = np.append(breakPoints_recap, b)

# Initialization
id_site = 0
id_block_right = 1
LF_block_list = np.array([])
LF_block = 0
effect_block = np.zeros(N)
t = time()
for v in ts.variants():
    pos_site = pos[id_site]
    while pos_site > breakPoints_recap[id_block_right]:
        # Move to a new block
        id_block_right += 1
        #Skip the time-consuming LF calculation if no effect in any individual
        if sum(effect_block) > 0:
            # Phenotype without the block = Original phenotypes - effects of the block
            phenotype_without_block = ind_z - effect_block
            (w_local, w_foreign) = LF_fitness(ind_x, ind_y, phenotype_without_block,
                                              ind_x, dist_mate, sigma_w)
            LF_block = mean_LF - np.mean(w_local - w_foreign)
        else:
            LF_block = 0
        # Store the contribution of the block and reset
        LF_block_list = np.append(LF_block_list, LF_block)
        effect_block = np.zeros(N)
        LF_block = 0
    # Phenotypic effect of all mutations at focal site
    # Start from the first derived allele
    index_gt = 1
    while index_gt < len(mut_effect_lists[id_site]):
        #hide other mutations except the focal mutation
        focal_gt = np.array(v.genotypes)
        focal_gt[focal_gt != index_gt] = 0
        # effect of the focal mutation in each individual
        effect_mut_genomes = np.array(mut_effect_lists[id_site])[focal_gt]
        # Add up two genomes of each individual
        effect_mut_ind = (effect_mut_genomes[range(0, 2*N-1, 2)]
                        + effect_mut_genomes[range(1, 2*N, 2)])
        effect_block += effect_mut_ind
        index_gt += 1
    id_site += 1
    if id_site % 100 == 0:
        print(f"{id_site} sites processed")
# Add the last few blocks with no mutations
while id_block_right < len(breakPoints_recap):
    LF_block_list = np.append(LF_block_list, 0.0)
    id_block_right += 1
timer = time() - t
print(timer/60) # 13.13min

# Save the contribution of each block to LF
with open("delta_LF_block_recap.txt", "w") as fout:
    for item in LF_block_list:
        fout.write(str(item) + "\n" )
fout.close()

# LF_block_list1 = LF_block_list

# Age of each mutation
age = ts.mutations_time
pos_by_mut = ts.sites_position[ts.mutations_site]
effect_by_mut = []
for site in ts.sites():
    for mut in site.mutations:
        effect_by_mut.append(mut.metadata['mutation_list'][0]['selection_coeff'])
effect_by_mut = np.array(effect_by_mut)

# TMRCA of all samples at the position of each mutation
tmrca_mut = []
for p in pos_by_mut:
    tmrca_mut.append(tree_height(ts.at(p), max_tick))

# Remove negative LF values and 0 allele age for some plots
tempx = age[np.logical_and(delta_LF_mut > 0, age > 0)]
tempy = delta_LF_mut[np.logical_and(delta_LF_mut > 0, age > 0)]
tempx_log = np.log(tempx)
tempy_log = np.log(tempy)
res = stats.linregress(tempx_log, tempy_log)
spr = stats.spearmanr(age, delta_LF_mut)
spr_positive = stats.spearmanr(tempx, tempy)



# Pairwise env diff and pairwise TMRCA
# # V1: all individuas: too slow, 15 hours for 380 trees
# # Env diff matrix between pairwise individuals: N * N
# envDiff_ind_matrix = abs(optimal[:, np.newaxis] - optimal)
# # Zoom to a matrix for genomes (nodes at tip): 2N * 2N
# envDiff_node_matrix = envDiff_ind_matrix.repeat(2,0).repeat(2,1)
#
# # Pairwise TMRCA matrix by tree
# num_samples = ts.num_samples
# cor_list = np.zeros(shape=(ts.num_trees, 2))
# tree_id = 0
# for tree in ts_recap.trees():
#     tmrca_matrix = np.zeros(shape=(num_samples, num_samples))
#     # tmrca_matrix = tree.tmrca(ts.samples()[:, np.newaxis], ts.samples()) # tmrca does not take array
#     for i in np.arange(num_samples):
#         for j in np.arange(num_samples):
#             tmrca_matrix[i,j] = tree.tmrca(i, j)
#     # Save the correlation between pair-wise env matrix and TMRCA matrix
#     cor_list[tree_id, 0], cor_list[tree_id, 1] = stats.spearmanr(envDiff_node_matrix,
#                                                                  tmrca_matrix,
#                                                                  axis=None)
#     tree_id += 1

# V2: with subsampling
# n individuals nearest to the n percentiles of environmental optimal
n = 200 # sample size
env_qt = np.percentile(optimal, np.arange(0, 100, 100/n),
                       method="nearest")
subsample_ind_id = []
for q in env_qt:
    subsample_ind_id = np.append(subsample_ind_id, np.where(ind_x == q))
subsample_ind_id = subsample_ind_id.astype(int)
# Transform individual id to genome id
subsample_id = subsample_ind_id.repeat(2)*2 + np.tile([0,1], reps=n)

# Env diff matrix between pairwise individuals: n * n
envDiff_ind_matrix = abs(env_qt[:, np.newaxis] - env_qt)
# Zoom to a matrix for genomes (nodes at tip): 2n * 2n
envDiff_node_matrix = envDiff_ind_matrix.repeat(2,0).repeat(2,1)

# Pairwise TMRCA matrix by tree
t = time()
n2 = n*2
cor_list = np.zeros(shape=(ts_recap.num_trees, 2))
tree_id = 0
for tree in ts_recap.trees():
    tmrca_matrix = np.zeros(shape=(n2, n2))
    # tmrca_matrix = tree.tmrca(ts.samples()[:, np.newaxis], ts.samples()) # tmrca does not take array
    for i in np.arange(n2):
        for j in np.arange(n2):
            tmrca_matrix[i,j] = tree.tmrca(subsample_id[i], subsample_id[j])
    # Save the correlation between pair-wise env matrix and TMRCA matrix
    cor_list[tree_id, 0], cor_list[tree_id, 1] = stats.spearmanr(envDiff_node_matrix,
                                                                 tmrca_matrix,
                                                                 axis=None)
    tree_id += 1
timer = time() - t
print(timer/60)


plt.stairs(cor_list[:,0], breakPoints_recap/1000)
plt.stairs(LF_block_list, breakPoints_recap/1000)
#plt.show()
plt.xlabel("Genomic positions (kb)")
plt.savefig("output/continuousWF_localAdapt_corEnvDiffTMRCA_LFblock_recap.png",
            dpi=300)

plt.scatter(cor_list[:,0], LF_block_list,
            marker="o",
            c="saddlebrown", alpha=0.2)
plt.xlabel("$LF_{block}$")
plt.ylabel("cor_ET")
plt.savefig("output/continuousWF_localAdapt_corEnvDiffTMRCA_LFblock_recap_scatter.png",
            dpi=300)
stats.spearmanr(cor_list[:,0], LF_block_list)





# Plot
# Hist LF
plt.hist(delta_LF_mut, bins=100,
         color="grey")
plt.xlabel("$LF_{mutation}$")
plt.ylabel("Count")
plt.savefig("output/continuousWF_localAdapt_ageAndLF_LFhist.png",
            dpi=300)
plt.close()
# Hist positive LF
plt.hist(tempy, bins=100,
         color="grey")
# plt.title("With local adapation")
plt.xlabel("$LF_{mutation}$")
plt.ylabel("Count")
plt.savefig("output/continuousWF_localAdapt_LFhist_positive.png",
            dpi=300)
plt.close()



# LF ~ phenotypic effect size
plt.plot(abs(mut_effect), delta_LF_mut,
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.1)
plt.xlabel("|Phenptypic effect size|")
# plt.ylabel("$LF_{mutation}$ (ln)")
plt.ylabel("$LF_{mutation}$")
# plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
#             dpi=100)
plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF.png",
            dpi=300)
plt.close()

# LF ~ allele age
#np.seterr(divide = 'ignore')
plt.figure(1)
plt.plot(tempx_log, tempy_log,
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.1,
         label="Spearman's rho: "+str(spr)+"\n" + "p-value: 2.66e-22")
# plt.plot(tempx_log, res.intercept + tempy_log*res.slope,
#          color = "cornflowerblue")
# plt.axline((0,res.intercept),
#            slope=res.slope, color="cornflowerblue",
#            label = "")
# plt.title("With local adapation")
plt.xlabel("Mutation age (ln)")
plt.ylabel("$LF_{mutation}$ (ln)")
#plt.xscale("linear")
#plt.yscale("linear")
plt.savefig("output/continuousWF_localAdapt_ageAndLF_ln.png",
            dpi=300)
plt.close()

# LF ~ pheno effect size, colored by age
plt.scatter(abs(mut_effect), np.log(delta_LF_mut),
         marker="o",
         c=age, alpha=0.2)
plt.xlabel("|Phenptypic effect size|")
plt.ylabel("$LF_{mutation}$ (ln)")
plt.colorbar()
# plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
#             dpi=100)
plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln_ageColor.png",
            dpi=300)
plt.close()



# Tree height ~ LF_mut
plt.scatter(np.log(tmrca_mut), np.log(delta_LF_mut),
         marker="o",
         c=age, alpha=0.2)
plt.ylabel("$LF_{mutation}$ (ln)")
plt.xlabel("TMRCA at the position (ln)")
plt.colorbar()
# plt.savefig("output/continuousWF_localAdapt_phenoEffectAndLF_ln.png",
#             dpi=100)
plt.savefig("output/continuousWF_localAdapt_LFAndTMRCA_ageColor.png",
            dpi=300)
plt.close()






# Plot together with tree height
fig, axs = plt.subplots(3, 1)
fig.set_figheight(12)
# plot 0: TMRCA with the contribution of sites to local adaptation (delta LF)
axs[0].stairs(tmrca_recap, kb_recap, baseline=None,
           color="mediumaquamarine")
axs[0].plot(pos_by_mut/1000, delta_LF_mut*1e6+1e4,
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.05)
axs[0].set_title("$LF_{mutation}$")

# # plot 1: TMRCA with absolute phenotypic effect size
# axs[1].stairs(tmrca_recap, kb_recap, baseline=None,
#            color="mediumaquamarine")
# axs[1].plot(pos_by_mut/1000, abs(effect_by_mut*1e5)+1e4,
#          marker="o", linestyle="",
#          color="saddlebrown", alpha=0.1)
# axs[1].set_title("|Phenotypic effect size|")

# plot 1: TMRCA with absolute phenotypic effect size
axs[1].stairs(tmrca_recap, kb_recap, baseline=None,
           color="mediumaquamarine")
axs[1].scatter(pos_by_mut/1000, abs(effect_by_mut*1e5)+1e4,
         marker="o",
         c=age, alpha=0.1)
axs[1].set_title("|Phenotypic effect size|")

# plot 2: TMRCA with allele age
axs[2].stairs(tmrca_recap, kb_recap, baseline=None,
           color="mediumaquamarine")
axs[2].plot(pos_by_mut/1000, age*5,
         marker="o", linestyle="",
         color="saddlebrown", alpha=0.1)
axs[2].set_title("Allele age")

# # plot 3: TMRCA with absolute phenotypic effect size * allele age
# axs[3].stairs(tmrca_recap, kb_recap, baseline=None,
#            color="mediumaquamarine")
# axs[3].plot(pos_by_mut/1000, age*(effect_by_mut)**2*200,
#          marker="o", linestyle="",
#          color="saddlebrown", alpha=0.1)
# axs[3].set_title("Absolute phenotypic effect size * Allele age")
# plt.show()
plt.savefig("output/continuousWF_localAdapt_treeHeight_recap_plus4Variables_color.png",
            dpi=300)
plt.close()


#Tree height with LF block
plt.stairs(tmrca_recap, kb_recap, baseline=None,
           color="mediumaquamarine")
plt.stairs(LF_block_list*1e5, breakPoints/1000)
plt.savefig("output/continuousWF_localAdapt_treeHeight_recap_LFblock.png",
            dpi=300)
plt.close()

np.corrcoef(tmrca_recap, LF_block_list)


